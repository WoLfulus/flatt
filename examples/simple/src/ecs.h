// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ECS_H_
#define FLATBUFFERS_GENERATED_ECS_H_

#pragma clang system_header


#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "array"

struct Vector2;

struct Position;
struct PositionBuilder;
struct PositionT;

struct Velocity;
struct VelocityBuilder;
struct VelocityT;

struct Player;
struct PlayerBuilder;
struct PlayerT;

struct Status;
struct StatusBuilder;
struct StatusT;

bool operator==(const Vector2 &lhs, const Vector2 &rhs);
bool operator!=(const Vector2 &lhs, const Vector2 &rhs);
bool operator==(const PositionT &lhs, const PositionT &rhs);
bool operator!=(const PositionT &lhs, const PositionT &rhs);
bool operator==(const VelocityT &lhs, const VelocityT &rhs);
bool operator!=(const VelocityT &lhs, const VelocityT &rhs);
bool operator==(const PlayerT &lhs, const PlayerT &rhs);
bool operator!=(const PlayerT &lhs, const PlayerT &rhs);
bool operator==(const StatusT &lhs, const StatusT &rhs);
bool operator!=(const StatusT &lhs, const StatusT &rhs);

inline const ::flatbuffers::TypeTable *Vector2TypeTable();

inline const ::flatbuffers::TypeTable *PositionTypeTable();

inline const ::flatbuffers::TypeTable *VelocityTypeTable();

inline const ::flatbuffers::TypeTable *PlayerTypeTable();

inline const ::flatbuffers::TypeTable *StatusTypeTable();

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Vector2TypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "Vector2";
  }
  Vector2()
      : x_(0),
        y_(0) {
  }
  Vector2(float _x, float _y)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    ::flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    ::flatbuffers::WriteScalar(&y_, _y);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return x();
    else if constexpr (Index == 1) return y();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(Vector2, 8);

inline bool operator==(const Vector2 &lhs, const Vector2 &rhs) {
  return
      (lhs.x() == rhs.x()) &&
      (lhs.y() == rhs.y());
}

inline bool operator!=(const Vector2 &lhs, const Vector2 &rhs) {
    return !(lhs == rhs);
}


struct Vector2::Traits {
  using type = Vector2;
  static constexpr auto name = "Vector2";
  static constexpr auto fully_qualified_name = "Vector2";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "x",
    "y"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct PositionT : public ::flatbuffers::NativeTable {
  typedef Position TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "PositionT";
  }
  std::unique_ptr<Vector2> value{};
  PositionT() = default;
  PositionT(const PositionT &o);
  PositionT(PositionT&&) FLATBUFFERS_NOEXCEPT = default;
  PositionT &operator=(PositionT o) FLATBUFFERS_NOEXCEPT;
};

struct Position FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PositionT NativeTableType;
  typedef PositionBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PositionTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "Position";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const Vector2 * _Nullable value() const {
    return GetStruct<const Vector2 *>(VT_VALUE);
  }
  Vector2 * _Nullable mutable_value() {
    return GetStruct<Vector2 * _Nullable >(VT_VALUE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vector2>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
  PositionT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PositionT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Position> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PositionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PositionBuilder {
  typedef Position Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(const Vector2 *value) {
    fbb_.AddStruct(Position::VT_VALUE, value);
  }
  explicit PositionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Position> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Position>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Position> CreatePosition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Vector2 *value = nullptr) {
  PositionBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Position::Traits {
  using type = Position;
  static auto constexpr Create = CreatePosition;
  static constexpr auto name = "Position";
  static constexpr auto fully_qualified_name = "Position";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

::flatbuffers::Offset<Position> CreatePosition(::flatbuffers::FlatBufferBuilder &_fbb, const PositionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VelocityT : public ::flatbuffers::NativeTable {
  typedef Velocity TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "VelocityT";
  }
  std::unique_ptr<Vector2> value{};
  VelocityT() = default;
  VelocityT(const VelocityT &o);
  VelocityT(VelocityT&&) FLATBUFFERS_NOEXCEPT = default;
  VelocityT &operator=(VelocityT o) FLATBUFFERS_NOEXCEPT;
};

struct Velocity FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VelocityT NativeTableType;
  typedef VelocityBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VelocityTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "Velocity";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const Vector2 * _Nullable value() const {
    return GetStruct<const Vector2 *>(VT_VALUE);
  }
  Vector2 * _Nullable mutable_value() {
    return GetStruct<Vector2 * _Nullable >(VT_VALUE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vector2>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
  VelocityT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VelocityT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Velocity> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VelocityT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VelocityBuilder {
  typedef Velocity Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(const Vector2 *value) {
    fbb_.AddStruct(Velocity::VT_VALUE, value);
  }
  explicit VelocityBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Velocity> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Velocity>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Velocity> CreateVelocity(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Vector2 *value = nullptr) {
  VelocityBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Velocity::Traits {
  using type = Velocity;
  static auto constexpr Create = CreateVelocity;
  static constexpr auto name = "Velocity";
  static constexpr auto fully_qualified_name = "Velocity";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

::flatbuffers::Offset<Velocity> CreateVelocity(::flatbuffers::FlatBufferBuilder &_fbb, const VelocityT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PlayerT : public ::flatbuffers::NativeTable {
  typedef Player TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "PlayerT";
  }
  std::unique_ptr<PositionT> position{};
  std::unique_ptr<VelocityT> velocity{};
  PlayerT() = default;
  PlayerT(const PlayerT &o);
  PlayerT(PlayerT&&) FLATBUFFERS_NOEXCEPT = default;
  PlayerT &operator=(PlayerT o) FLATBUFFERS_NOEXCEPT;
};

struct Player FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerT NativeTableType;
  typedef PlayerBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PlayerTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "Player";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4,
    VT_VELOCITY = 6
  };
  const Position * _Nullable position() const {
    return GetPointer<const Position *>(VT_POSITION);
  }
  Position * _Nullable mutable_position() {
    return GetPointer<Position * _Nullable >(VT_POSITION);
  }
  const Velocity * _Nullable velocity() const {
    return GetPointer<const Velocity *>(VT_VELOCITY);
  }
  Velocity * _Nullable mutable_velocity() {
    return GetPointer<Velocity * _Nullable >(VT_VELOCITY);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return position();
    else if constexpr (Index == 1) return velocity();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           VerifyOffset(verifier, VT_VELOCITY) &&
           verifier.VerifyTable(velocity()) &&
           verifier.EndTable();
  }
  PlayerT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PlayerT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Player> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PlayerBuilder {
  typedef Player Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_position(::flatbuffers::Offset<Position> position) {
    fbb_.AddOffset(Player::VT_POSITION, position);
  }
  void add_velocity(::flatbuffers::Offset<Velocity> velocity) {
    fbb_.AddOffset(Player::VT_VELOCITY, velocity);
  }
  explicit PlayerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Player> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Player>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Player> CreatePlayer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Position> position = 0,
    ::flatbuffers::Offset<Velocity> velocity = 0) {
  PlayerBuilder builder_(_fbb);
  builder_.add_velocity(velocity);
  builder_.add_position(position);
  return builder_.Finish();
}

struct Player::Traits {
  using type = Player;
  static auto constexpr Create = CreatePlayer;
  static constexpr auto name = "Player";
  static constexpr auto fully_qualified_name = "Player";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "position",
    "velocity"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

::flatbuffers::Offset<Player> CreatePlayer(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StatusT : public ::flatbuffers::NativeTable {
  typedef Status TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "StatusT";
  }
};

struct Status FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StatusT NativeTableType;
  typedef StatusBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StatusTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "Status";
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  StatusT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StatusT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Status> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StatusT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StatusBuilder {
  typedef Status Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit StatusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Status> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Status>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Status> CreateStatus(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  StatusBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Status::Traits {
  using type = Status;
  static auto constexpr Create = CreateStatus;
  static constexpr auto name = "Status";
  static constexpr auto fully_qualified_name = "Status";
  static constexpr size_t fields_number = 0;
  static constexpr std::array<const char *, fields_number> field_names = {};
};

::flatbuffers::Offset<Status> CreateStatus(::flatbuffers::FlatBufferBuilder &_fbb, const StatusT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const PositionT &lhs, const PositionT &rhs) {
  return
      ((lhs.value == rhs.value) || (lhs.value && rhs.value && *lhs.value == *rhs.value));
}

inline bool operator!=(const PositionT &lhs, const PositionT &rhs) {
    return !(lhs == rhs);
}


inline PositionT::PositionT(const PositionT &o)
      : value((o.value) ? new Vector2(*o.value) : nullptr) {
}

inline PositionT &PositionT::operator=(PositionT o) FLATBUFFERS_NOEXCEPT {
  std::swap(value, o.value);
  return *this;
}

inline PositionT *Position::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<PositionT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Position::UnPackTo(PositionT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); if (_e) _o->value = std::unique_ptr<Vector2>(new Vector2(*_e)); }
}

inline ::flatbuffers::Offset<Position> Position::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PositionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePosition(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Position> CreatePosition(::flatbuffers::FlatBufferBuilder &_fbb, const PositionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PositionT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value ? _o->value.get() : nullptr;
  return CreatePosition(
      _fbb,
      _value);
}


inline bool operator==(const VelocityT &lhs, const VelocityT &rhs) {
  return
      ((lhs.value == rhs.value) || (lhs.value && rhs.value && *lhs.value == *rhs.value));
}

inline bool operator!=(const VelocityT &lhs, const VelocityT &rhs) {
    return !(lhs == rhs);
}


inline VelocityT::VelocityT(const VelocityT &o)
      : value((o.value) ? new Vector2(*o.value) : nullptr) {
}

inline VelocityT &VelocityT::operator=(VelocityT o) FLATBUFFERS_NOEXCEPT {
  std::swap(value, o.value);
  return *this;
}

inline VelocityT *Velocity::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<VelocityT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Velocity::UnPackTo(VelocityT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); if (_e) _o->value = std::unique_ptr<Vector2>(new Vector2(*_e)); }
}

inline ::flatbuffers::Offset<Velocity> Velocity::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VelocityT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVelocity(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Velocity> CreateVelocity(::flatbuffers::FlatBufferBuilder &_fbb, const VelocityT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const VelocityT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value ? _o->value.get() : nullptr;
  return CreateVelocity(
      _fbb,
      _value);
}


inline bool operator==(const PlayerT &lhs, const PlayerT &rhs) {
  return
      ((lhs.position == rhs.position) || (lhs.position && rhs.position && *lhs.position == *rhs.position)) &&
      ((lhs.velocity == rhs.velocity) || (lhs.velocity && rhs.velocity && *lhs.velocity == *rhs.velocity));
}

inline bool operator!=(const PlayerT &lhs, const PlayerT &rhs) {
    return !(lhs == rhs);
}


inline PlayerT::PlayerT(const PlayerT &o)
      : position((o.position) ? new PositionT(*o.position) : nullptr),
        velocity((o.velocity) ? new VelocityT(*o.velocity) : nullptr) {
}

inline PlayerT &PlayerT::operator=(PlayerT o) FLATBUFFERS_NOEXCEPT {
  std::swap(position, o.position);
  std::swap(velocity, o.velocity);
  return *this;
}

inline PlayerT *Player::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<PlayerT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Player::UnPackTo(PlayerT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = position(); if (_e) { if(_o->position) { _e->UnPackTo(_o->position.get(), _resolver); } else { _o->position = std::unique_ptr<PositionT>(_e->UnPack(_resolver)); } } else if (_o->position) { _o->position.reset(); } }
  { auto _e = velocity(); if (_e) { if(_o->velocity) { _e->UnPackTo(_o->velocity.get(), _resolver); } else { _o->velocity = std::unique_ptr<VelocityT>(_e->UnPack(_resolver)); } } else if (_o->velocity) { _o->velocity.reset(); } }
}

inline ::flatbuffers::Offset<Player> Player::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePlayer(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Player> CreatePlayer(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PlayerT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _position = _o->position ? CreatePosition(_fbb, _o->position.get(), _rehasher) : 0;
  auto _velocity = _o->velocity ? CreateVelocity(_fbb, _o->velocity.get(), _rehasher) : 0;
  return CreatePlayer(
      _fbb,
      _position,
      _velocity);
}


inline bool operator==(const StatusT &, const StatusT &) {
  return true;
}

inline bool operator!=(const StatusT &lhs, const StatusT &rhs) {
    return !(lhs == rhs);
}


inline StatusT *Status::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<StatusT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Status::UnPackTo(StatusT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<Status> Status::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StatusT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStatus(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Status> CreateStatus(::flatbuffers::FlatBufferBuilder &_fbb, const StatusT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StatusT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return CreateStatus(
      _fbb);
}

inline const ::flatbuffers::TypeTable *Vector2TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8 };
  static const char * const names[] = {
    "x",
    "y"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 2, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *PositionTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    Vector2TypeTable
  };
  static const char * const names[] = {
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *VelocityTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    Vector2TypeTable
  };
  static const char * const names[] = {
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *PlayerTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    PositionTypeTable,
    VelocityTypeTable
  };
  static const char * const names[] = {
    "position",
    "velocity"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *StatusTypeTable() {
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

#endif  // FLATBUFFERS_GENERATED_ECS_H_
