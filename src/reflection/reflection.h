// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_REFLECTION_REFLECTION_H_
#define FLATBUFFERS_GENERATED_REFLECTION_REFLECTION_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(
  FLATBUFFERS_VERSION_MAJOR == 24 && FLATBUFFERS_VERSION_MINOR == 3 && FLATBUFFERS_VERSION_REVISION == 25,
  "Non-compatible flatbuffers version included");

#include "array"

namespace reflection {

  struct Type;
  struct TypeBuilder;
  struct TypeT;

  struct KeyValue;
  struct KeyValueBuilder;
  struct KeyValueT;

  struct EnumVal;
  struct EnumValBuilder;
  struct EnumValT;

  struct Enum;
  struct EnumBuilder;
  struct EnumT;

  struct Field;
  struct FieldBuilder;
  struct FieldT;

  struct Object;
  struct ObjectBuilder;
  struct ObjectT;

  struct RPCCall;
  struct RPCCallBuilder;
  struct RPCCallT;

  struct Service;
  struct ServiceBuilder;
  struct ServiceT;

  struct SchemaFile;
  struct SchemaFileBuilder;
  struct SchemaFileT;

  struct Schema;
  struct SchemaBuilder;
  struct SchemaT;

  bool operator==(const TypeT &lhs, const TypeT &rhs);
  bool operator!=(const TypeT &lhs, const TypeT &rhs);
  bool operator==(const KeyValueT &lhs, const KeyValueT &rhs);
  bool operator!=(const KeyValueT &lhs, const KeyValueT &rhs);
  bool operator==(const EnumValT &lhs, const EnumValT &rhs);
  bool operator!=(const EnumValT &lhs, const EnumValT &rhs);
  bool operator==(const EnumT &lhs, const EnumT &rhs);
  bool operator!=(const EnumT &lhs, const EnumT &rhs);
  bool operator==(const FieldT &lhs, const FieldT &rhs);
  bool operator!=(const FieldT &lhs, const FieldT &rhs);
  bool operator==(const ObjectT &lhs, const ObjectT &rhs);
  bool operator!=(const ObjectT &lhs, const ObjectT &rhs);
  bool operator==(const RPCCallT &lhs, const RPCCallT &rhs);
  bool operator!=(const RPCCallT &lhs, const RPCCallT &rhs);
  bool operator==(const ServiceT &lhs, const ServiceT &rhs);
  bool operator!=(const ServiceT &lhs, const ServiceT &rhs);
  bool operator==(const SchemaFileT &lhs, const SchemaFileT &rhs);
  bool operator!=(const SchemaFileT &lhs, const SchemaFileT &rhs);
  bool operator==(const SchemaT &lhs, const SchemaT &rhs);
  bool operator!=(const SchemaT &lhs, const SchemaT &rhs);

  inline const ::flatbuffers::TypeTable *TypeTypeTable();

  inline const ::flatbuffers::TypeTable *KeyValueTypeTable();

  inline const ::flatbuffers::TypeTable *EnumValTypeTable();

  inline const ::flatbuffers::TypeTable *EnumTypeTable();

  inline const ::flatbuffers::TypeTable *FieldTypeTable();

  inline const ::flatbuffers::TypeTable *ObjectTypeTable();

  inline const ::flatbuffers::TypeTable *RPCCallTypeTable();

  inline const ::flatbuffers::TypeTable *ServiceTypeTable();

  inline const ::flatbuffers::TypeTable *SchemaFileTypeTable();

  inline const ::flatbuffers::TypeTable *SchemaTypeTable();

  enum class BaseType : int8_t {
    None = 0,
    UType = 1,
    Bool = 2,
    Byte = 3,
    UByte = 4,
    Short = 5,
    UShort = 6,
    Int = 7,
    UInt = 8,
    Long = 9,
    ULong = 10,
    Float = 11,
    Double = 12,
    String = 13,
    Vector = 14,
    Obj = 15,
    Union = 16,
    Array = 17,
    Vector64 = 18,
    MaxBaseType = 19,
    MIN = None,
    MAX = MaxBaseType
  };

  inline const BaseType (&EnumValuesBaseType())[20] {
    static const BaseType values[] = { BaseType::None,   BaseType::UType,  BaseType::Bool,     BaseType::Byte,
                                       BaseType::UByte,  BaseType::Short,  BaseType::UShort,   BaseType::Int,
                                       BaseType::UInt,   BaseType::Long,   BaseType::ULong,    BaseType::Float,
                                       BaseType::Double, BaseType::String, BaseType::Vector,   BaseType::Obj,
                                       BaseType::Union,  BaseType::Array,  BaseType::Vector64, BaseType::MaxBaseType };
    return values;
  }

  inline const char *const *EnumNamesBaseType() {
    static const char *const names[21] = { "None",   "UType", "Bool",  "Byte",  "UByte",    "Short",       "UShort",
                                           "Int",    "UInt",  "Long",  "ULong", "Float",    "Double",      "String",
                                           "Vector", "Obj",   "Union", "Array", "Vector64", "MaxBaseType", nullptr };
    return names;
  }

  inline const char *EnumNameBaseType(BaseType e) {
    if (::flatbuffers::IsOutRange(e, BaseType::None, BaseType::MaxBaseType))
      return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesBaseType()[index];
  }

  /// New schema language features that are not supported by old code generators.
  enum class AdvancedFeatures : uint64_t {
    AdvancedArrayFeatures = 1ULL,
    AdvancedUnionFeatures = 2ULL,
    OptionalScalars = 4ULL,
    DefaultVectorsAndStrings = 8ULL,
    NONE = 0,
    ANY = 15ULL
  };
  FLATBUFFERS_DEFINE_BITMASK_OPERATORS(AdvancedFeatures, uint64_t)

  inline const AdvancedFeatures (&EnumValuesAdvancedFeatures())[4] {
    static const AdvancedFeatures values[] = { AdvancedFeatures::AdvancedArrayFeatures,
                                               AdvancedFeatures::AdvancedUnionFeatures,
                                               AdvancedFeatures::OptionalScalars,
                                               AdvancedFeatures::DefaultVectorsAndStrings };
    return values;
  }

  inline const char *const *EnumNamesAdvancedFeatures() {
    static const char *const names[9] = { "AdvancedArrayFeatures",
                                          "AdvancedUnionFeatures",
                                          "",
                                          "OptionalScalars",
                                          "",
                                          "",
                                          "",
                                          "DefaultVectorsAndStrings",
                                          nullptr };
    return names;
  }

  inline const char *EnumNameAdvancedFeatures(AdvancedFeatures e) {
    if (::flatbuffers::IsOutRange(
          e, AdvancedFeatures::AdvancedArrayFeatures, AdvancedFeatures::DefaultVectorsAndStrings))
      return "";
    const size_t index = static_cast<size_t>(e) - static_cast<size_t>(AdvancedFeatures::AdvancedArrayFeatures);
    return EnumNamesAdvancedFeatures()[index];
  }

  struct TypeT : public ::flatbuffers::NativeTable {
    typedef Type TableType;

    static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
      return "reflection.TypeT";
    }

    reflection::BaseType base_type = reflection::BaseType::None;
    reflection::BaseType element = reflection::BaseType::None;
    int32_t index = -1;
    uint16_t fixed_length = 0;
    uint32_t base_size = 4;
    uint32_t element_size = 0;
  };

  struct Type FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef TypeT NativeTableType;
    typedef TypeBuilder Builder;
    struct Traits;

    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
      return TypeTypeTable();
    }

    static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
      return "reflection.Type";
    }

    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
      VT_BASE_TYPE = 4,
      VT_ELEMENT = 6,
      VT_INDEX = 8,
      VT_FIXED_LENGTH = 10,
      VT_BASE_SIZE = 12,
      VT_ELEMENT_SIZE = 14
    };

    reflection::BaseType base_type() const {
      return static_cast<reflection::BaseType>(GetField<int8_t>(VT_BASE_TYPE, 0));
    }

    bool mutate_base_type(reflection::BaseType _base_type = static_cast<reflection::BaseType>(0)) {
      return SetField<int8_t>(VT_BASE_TYPE, static_cast<int8_t>(_base_type), 0);
    }

    reflection::BaseType element() const {
      return static_cast<reflection::BaseType>(GetField<int8_t>(VT_ELEMENT, 0));
    }

    bool mutate_element(reflection::BaseType _element = static_cast<reflection::BaseType>(0)) {
      return SetField<int8_t>(VT_ELEMENT, static_cast<int8_t>(_element), 0);
    }

    int32_t index() const {
      return GetField<int32_t>(VT_INDEX, -1);
    }

    bool mutate_index(int32_t _index = -1) {
      return SetField<int32_t>(VT_INDEX, _index, -1);
    }

    uint16_t fixed_length() const {
      return GetField<uint16_t>(VT_FIXED_LENGTH, 0);
    }

    bool mutate_fixed_length(uint16_t _fixed_length = 0) {
      return SetField<uint16_t>(VT_FIXED_LENGTH, _fixed_length, 0);
    }

    /// The size (octets) of the `base_type` field.
    uint32_t base_size() const {
      return GetField<uint32_t>(VT_BASE_SIZE, 4);
    }

    bool mutate_base_size(uint32_t _base_size = 4) {
      return SetField<uint32_t>(VT_BASE_SIZE, _base_size, 4);
    }

    /// The size (octets) of the `element` field, if present.
    uint32_t element_size() const {
      return GetField<uint32_t>(VT_ELEMENT_SIZE, 0);
    }

    bool mutate_element_size(uint32_t _element_size = 0) {
      return SetField<uint32_t>(VT_ELEMENT_SIZE, _element_size, 0);
    }

    template <size_t Index>
    auto get_field() const {
      if constexpr (Index == 0)
        return base_type();
      else if constexpr (Index == 1)
        return element();
      else if constexpr (Index == 2)
        return index();
      else if constexpr (Index == 3)
        return fixed_length();
      else if constexpr (Index == 4)
        return base_size();
      else if constexpr (Index == 5)
        return element_size();
      else
        static_assert(Index != Index, "Invalid Field Index");
    }

    bool Verify(::flatbuffers::Verifier &verifier) const {
      return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_BASE_TYPE, 1) &&
             VerifyField<int8_t>(verifier, VT_ELEMENT, 1) && VerifyField<int32_t>(verifier, VT_INDEX, 4) &&
             VerifyField<uint16_t>(verifier, VT_FIXED_LENGTH, 2) && VerifyField<uint32_t>(verifier, VT_BASE_SIZE, 4) &&
             VerifyField<uint32_t>(verifier, VT_ELEMENT_SIZE, 4) && verifier.EndTable();
    }

    TypeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(TypeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static ::flatbuffers::Offset<Type> Pack(
      ::flatbuffers::FlatBufferBuilder &_fbb, const TypeT *_o,
      const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
  };

  struct TypeBuilder {
    typedef Type Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;

    void add_base_type(reflection::BaseType base_type) {
      fbb_.AddElement<int8_t>(Type::VT_BASE_TYPE, static_cast<int8_t>(base_type), 0);
    }

    void add_element(reflection::BaseType element) {
      fbb_.AddElement<int8_t>(Type::VT_ELEMENT, static_cast<int8_t>(element), 0);
    }

    void add_index(int32_t index) {
      fbb_.AddElement<int32_t>(Type::VT_INDEX, index, -1);
    }

    void add_fixed_length(uint16_t fixed_length) {
      fbb_.AddElement<uint16_t>(Type::VT_FIXED_LENGTH, fixed_length, 0);
    }

    void add_base_size(uint32_t base_size) {
      fbb_.AddElement<uint32_t>(Type::VT_BASE_SIZE, base_size, 4);
    }

    void add_element_size(uint32_t element_size) {
      fbb_.AddElement<uint32_t>(Type::VT_ELEMENT_SIZE, element_size, 0);
    }

    explicit TypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
      start_ = fbb_.StartTable();
    }

    ::flatbuffers::Offset<Type> Finish() {
      const auto end = fbb_.EndTable(start_);
      auto o = ::flatbuffers::Offset<Type>(end);
      return o;
    }
  };

  inline ::flatbuffers::Offset<Type> CreateType(
    ::flatbuffers::FlatBufferBuilder &_fbb, reflection::BaseType base_type = reflection::BaseType::None,
    reflection::BaseType element = reflection::BaseType::None, int32_t index = -1, uint16_t fixed_length = 0,
    uint32_t base_size = 4, uint32_t element_size = 0) {
    TypeBuilder builder_(_fbb);
    builder_.add_element_size(element_size);
    builder_.add_base_size(base_size);
    builder_.add_index(index);
    builder_.add_fixed_length(fixed_length);
    builder_.add_element(element);
    builder_.add_base_type(base_type);
    return builder_.Finish();
  }

  struct Type::Traits {
    using type = Type;
    static auto constexpr Create = CreateType;
    static constexpr auto name = "Type";
    static constexpr auto fully_qualified_name = "reflection.Type";
    static constexpr size_t fields_number = 6;
    static constexpr std::array<const char *, fields_number> field_names = {
      "base_type", "element", "index", "fixed_length", "base_size", "element_size"
    };
    template <size_t Index>
    using FieldType = decltype(std::declval<type>().get_field<Index>());
  };

  ::flatbuffers::Offset<Type> CreateType(
    ::flatbuffers::FlatBufferBuilder &_fbb, const TypeT *_o,
    const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

  struct KeyValueT : public ::flatbuffers::NativeTable {
    typedef KeyValue TableType;

    static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
      return "reflection.KeyValueT";
    }

    std::string key{};
    std::string value{};
  };

  struct KeyValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef KeyValueT NativeTableType;
    typedef KeyValueBuilder Builder;
    struct Traits;

    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
      return KeyValueTypeTable();
    }

    static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
      return "reflection.KeyValue";
    }

    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
      VT_KEY = 4,
      VT_VALUE = 6
    };

    const ::flatbuffers::String *key() const {
      return GetPointer<const ::flatbuffers::String *>(VT_KEY);
    }

    ::flatbuffers::String *mutable_key() {
      return GetPointer<::flatbuffers::String *>(VT_KEY);
    }

    bool KeyCompareLessThan(const KeyValue *const o) const {
      return *key() < *o->key();
    }

    int KeyCompareWithValue(const char *_key) const {
      return strcmp(key()->c_str(), _key);
    }

    template <typename StringType>
    int KeyCompareWithValue(const StringType &_key) const {
      if (key()->c_str() < _key)
        return -1;
      if (_key < key()->c_str())
        return 1;
      return 0;
    }

    const ::flatbuffers::String *value() const {
      return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
    }

    ::flatbuffers::String *mutable_value() {
      return GetPointer<::flatbuffers::String *>(VT_VALUE);
    }

    template <size_t Index>
    auto get_field() const {
      if constexpr (Index == 0)
        return key();
      else if constexpr (Index == 1)
        return value();
      else
        static_assert(Index != Index, "Invalid Field Index");
    }

    bool Verify(::flatbuffers::Verifier &verifier) const {
      return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_KEY) && verifier.VerifyString(key()) &&
             VerifyOffset(verifier, VT_VALUE) && verifier.VerifyString(value()) && verifier.EndTable();
    }

    KeyValueT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(KeyValueT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static ::flatbuffers::Offset<KeyValue> Pack(
      ::flatbuffers::FlatBufferBuilder &_fbb, const KeyValueT *_o,
      const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
  };

  struct KeyValueBuilder {
    typedef KeyValue Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;

    void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
      fbb_.AddOffset(KeyValue::VT_KEY, key);
    }

    void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
      fbb_.AddOffset(KeyValue::VT_VALUE, value);
    }

    explicit KeyValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
      start_ = fbb_.StartTable();
    }

    ::flatbuffers::Offset<KeyValue> Finish() {
      const auto end = fbb_.EndTable(start_);
      auto o = ::flatbuffers::Offset<KeyValue>(end);
      fbb_.Required(o, KeyValue::VT_KEY);
      return o;
    }
  };

  inline ::flatbuffers::Offset<KeyValue> CreateKeyValue(
    ::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
    KeyValueBuilder builder_(_fbb);
    builder_.add_value(value);
    builder_.add_key(key);
    return builder_.Finish();
  }

  struct KeyValue::Traits {
    using type = KeyValue;
    static auto constexpr Create = CreateKeyValue;
    static constexpr auto name = "KeyValue";
    static constexpr auto fully_qualified_name = "reflection.KeyValue";
    static constexpr size_t fields_number = 2;
    static constexpr std::array<const char *, fields_number> field_names = { "key", "value" };
    template <size_t Index>
    using FieldType = decltype(std::declval<type>().get_field<Index>());
  };

  inline ::flatbuffers::Offset<KeyValue> CreateKeyValueDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, const char *key = nullptr, const char *value = nullptr) {
    auto key__ = key ? _fbb.CreateString(key) : 0;
    auto value__ = value ? _fbb.CreateString(value) : 0;
    return reflection::CreateKeyValue(_fbb, key__, value__);
  }

  ::flatbuffers::Offset<KeyValue> CreateKeyValue(
    ::flatbuffers::FlatBufferBuilder &_fbb, const KeyValueT *_o,
    const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

  struct EnumValT : public ::flatbuffers::NativeTable {
    typedef EnumVal TableType;

    static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
      return "reflection.EnumValT";
    }

    std::string name{};
    int64_t value = 0;
    std::unique_ptr<reflection::TypeT> union_type{};
    std::vector<std::string> documentation{};
    std::vector<std::unique_ptr<reflection::KeyValueT>> attributes{};
    EnumValT() = default;
    EnumValT(const EnumValT &o);
    EnumValT(EnumValT &&) FLATBUFFERS_NOEXCEPT = default;
    EnumValT &operator=(EnumValT o) FLATBUFFERS_NOEXCEPT;
  };

  struct EnumVal FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef EnumValT NativeTableType;
    typedef EnumValBuilder Builder;
    struct Traits;

    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
      return EnumValTypeTable();
    }

    static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
      return "reflection.EnumVal";
    }

    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
      VT_NAME = 4,
      VT_VALUE = 6,
      VT_UNION_TYPE = 10,
      VT_DOCUMENTATION = 12,
      VT_ATTRIBUTES = 14
    };

    const ::flatbuffers::String *name() const {
      return GetPointer<const ::flatbuffers::String *>(VT_NAME);
    }

    ::flatbuffers::String *mutable_name() {
      return GetPointer<::flatbuffers::String *>(VT_NAME);
    }

    int64_t value() const {
      return GetField<int64_t>(VT_VALUE, 0);
    }

    bool mutate_value(int64_t _value = 0) {
      return SetField<int64_t>(VT_VALUE, _value, 0);
    }

    bool KeyCompareLessThan(const EnumVal *const o) const {
      return value() < o->value();
    }

    int KeyCompareWithValue(int64_t _value) const {
      return static_cast<int>(value() > _value) - static_cast<int>(value() < _value);
    }

    const reflection::Type *union_type() const {
      return GetPointer<const reflection::Type *>(VT_UNION_TYPE);
    }

    reflection::Type *mutable_union_type() {
      return GetPointer<reflection::Type *>(VT_UNION_TYPE);
    }

    const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *documentation() const {
      return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DOCUMENTATION);
    }

    ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_documentation() {
      return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DOCUMENTATION);
    }

    const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *attributes() const {
      return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *>(VT_ATTRIBUTES);
    }

    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *mutable_attributes() {
      return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *>(VT_ATTRIBUTES);
    }

    template <size_t Index>
    auto get_field() const {
      if constexpr (Index == 0)
        return name();
      else if constexpr (Index == 1)
        return value();
      else if constexpr (Index == 2)
        return union_type();
      else if constexpr (Index == 3)
        return documentation();
      else if constexpr (Index == 4)
        return attributes();
      else
        static_assert(Index != Index, "Invalid Field Index");
    }

    bool Verify(::flatbuffers::Verifier &verifier) const {
      return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_NAME) && verifier.VerifyString(name()) &&
             VerifyField<int64_t>(verifier, VT_VALUE, 8) && VerifyOffset(verifier, VT_UNION_TYPE) &&
             verifier.VerifyTable(union_type()) && VerifyOffset(verifier, VT_DOCUMENTATION) &&
             verifier.VerifyVector(documentation()) && verifier.VerifyVectorOfStrings(documentation()) &&
             VerifyOffset(verifier, VT_ATTRIBUTES) && verifier.VerifyVector(attributes()) &&
             verifier.VerifyVectorOfTables(attributes()) && verifier.EndTable();
    }

    EnumValT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(EnumValT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static ::flatbuffers::Offset<EnumVal> Pack(
      ::flatbuffers::FlatBufferBuilder &_fbb, const EnumValT *_o,
      const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
  };

  struct EnumValBuilder {
    typedef EnumVal Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;

    void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
      fbb_.AddOffset(EnumVal::VT_NAME, name);
    }

    void add_value(int64_t value) {
      fbb_.AddElement<int64_t>(EnumVal::VT_VALUE, value, 0);
    }

    void add_union_type(::flatbuffers::Offset<reflection::Type> union_type) {
      fbb_.AddOffset(EnumVal::VT_UNION_TYPE, union_type);
    }

    void add_documentation(
      ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> documentation) {
      fbb_.AddOffset(EnumVal::VT_DOCUMENTATION, documentation);
    }

    void add_attributes(
      ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>>> attributes) {
      fbb_.AddOffset(EnumVal::VT_ATTRIBUTES, attributes);
    }

    explicit EnumValBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
      start_ = fbb_.StartTable();
    }

    ::flatbuffers::Offset<EnumVal> Finish() {
      const auto end = fbb_.EndTable(start_);
      auto o = ::flatbuffers::Offset<EnumVal>(end);
      fbb_.Required(o, EnumVal::VT_NAME);
      return o;
    }
  };

  inline ::flatbuffers::Offset<EnumVal> CreateEnumVal(
    ::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::String> name = 0, int64_t value = 0,
    ::flatbuffers::Offset<reflection::Type> union_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> documentation = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>>> attributes = 0) {
    EnumValBuilder builder_(_fbb);
    builder_.add_value(value);
    builder_.add_attributes(attributes);
    builder_.add_documentation(documentation);
    builder_.add_union_type(union_type);
    builder_.add_name(name);
    return builder_.Finish();
  }

  struct EnumVal::Traits {
    using type = EnumVal;
    static auto constexpr Create = CreateEnumVal;
    static constexpr auto name = "EnumVal";
    static constexpr auto fully_qualified_name = "reflection.EnumVal";
    static constexpr size_t fields_number = 5;
    static constexpr std::array<const char *, fields_number> field_names = { "name", "value", "union_type",
                                                                             "documentation", "attributes" };
    template <size_t Index>
    using FieldType = decltype(std::declval<type>().get_field<Index>());
  };

  inline ::flatbuffers::Offset<EnumVal> CreateEnumValDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr, int64_t value = 0,
    ::flatbuffers::Offset<reflection::Type> union_type = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *documentation = nullptr,
    std::vector<::flatbuffers::Offset<reflection::KeyValue>> *attributes = nullptr) {
    auto name__ = name ? _fbb.CreateString(name) : 0;
    auto documentation__ =
      documentation ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*documentation) : 0;
    auto attributes__ = attributes ? _fbb.CreateVectorOfSortedTables<reflection::KeyValue>(attributes) : 0;
    return reflection::CreateEnumVal(_fbb, name__, value, union_type, documentation__, attributes__);
  }

  ::flatbuffers::Offset<EnumVal> CreateEnumVal(
    ::flatbuffers::FlatBufferBuilder &_fbb, const EnumValT *_o,
    const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

  struct EnumT : public ::flatbuffers::NativeTable {
    typedef Enum TableType;

    static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
      return "reflection.EnumT";
    }

    std::string name{};
    std::vector<std::unique_ptr<reflection::EnumValT>> values{};
    bool is_union = false;
    std::unique_ptr<reflection::TypeT> underlying_type{};
    std::vector<std::unique_ptr<reflection::KeyValueT>> attributes{};
    std::vector<std::string> documentation{};
    std::string declaration_file{};
    EnumT() = default;
    EnumT(const EnumT &o);
    EnumT(EnumT &&) FLATBUFFERS_NOEXCEPT = default;
    EnumT &operator=(EnumT o) FLATBUFFERS_NOEXCEPT;
  };

  struct Enum FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef EnumT NativeTableType;
    typedef EnumBuilder Builder;
    struct Traits;

    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
      return EnumTypeTable();
    }

    static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
      return "reflection.Enum";
    }

    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
      VT_NAME = 4,
      VT_VALUES = 6,
      VT_IS_UNION = 8,
      VT_UNDERLYING_TYPE = 10,
      VT_ATTRIBUTES = 12,
      VT_DOCUMENTATION = 14,
      VT_DECLARATION_FILE = 16
    };

    const ::flatbuffers::String *name() const {
      return GetPointer<const ::flatbuffers::String *>(VT_NAME);
    }

    ::flatbuffers::String *mutable_name() {
      return GetPointer<::flatbuffers::String *>(VT_NAME);
    }

    bool KeyCompareLessThan(const Enum *const o) const {
      return *name() < *o->name();
    }

    int KeyCompareWithValue(const char *_name) const {
      return strcmp(name()->c_str(), _name);
    }

    template <typename StringType>
    int KeyCompareWithValue(const StringType &_name) const {
      if (name()->c_str() < _name)
        return -1;
      if (_name < name()->c_str())
        return 1;
      return 0;
    }

    const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::EnumVal>> *values() const {
      return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::EnumVal>> *>(VT_VALUES);
    }

    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::EnumVal>> *mutable_values() {
      return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<reflection::EnumVal>> *>(VT_VALUES);
    }

    bool is_union() const {
      return GetField<uint8_t>(VT_IS_UNION, 0) != 0;
    }

    bool mutate_is_union(bool _is_union = 0) {
      return SetField<uint8_t>(VT_IS_UNION, static_cast<uint8_t>(_is_union), 0);
    }

    const reflection::Type *underlying_type() const {
      return GetPointer<const reflection::Type *>(VT_UNDERLYING_TYPE);
    }

    reflection::Type *mutable_underlying_type() {
      return GetPointer<reflection::Type *>(VT_UNDERLYING_TYPE);
    }

    const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *attributes() const {
      return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *>(VT_ATTRIBUTES);
    }

    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *mutable_attributes() {
      return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *>(VT_ATTRIBUTES);
    }

    const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *documentation() const {
      return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DOCUMENTATION);
    }

    ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_documentation() {
      return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DOCUMENTATION);
    }

    /// File that this Enum is declared in.
    const ::flatbuffers::String *declaration_file() const {
      return GetPointer<const ::flatbuffers::String *>(VT_DECLARATION_FILE);
    }

    ::flatbuffers::String *mutable_declaration_file() {
      return GetPointer<::flatbuffers::String *>(VT_DECLARATION_FILE);
    }

    template <size_t Index>
    auto get_field() const {
      if constexpr (Index == 0)
        return name();
      else if constexpr (Index == 1)
        return values();
      else if constexpr (Index == 2)
        return is_union();
      else if constexpr (Index == 3)
        return underlying_type();
      else if constexpr (Index == 4)
        return attributes();
      else if constexpr (Index == 5)
        return documentation();
      else if constexpr (Index == 6)
        return declaration_file();
      else
        static_assert(Index != Index, "Invalid Field Index");
    }

    bool Verify(::flatbuffers::Verifier &verifier) const {
      return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_NAME) && verifier.VerifyString(name()) &&
             VerifyOffsetRequired(verifier, VT_VALUES) && verifier.VerifyVector(values()) &&
             verifier.VerifyVectorOfTables(values()) && VerifyField<uint8_t>(verifier, VT_IS_UNION, 1) &&
             VerifyOffsetRequired(verifier, VT_UNDERLYING_TYPE) && verifier.VerifyTable(underlying_type()) &&
             VerifyOffset(verifier, VT_ATTRIBUTES) && verifier.VerifyVector(attributes()) &&
             verifier.VerifyVectorOfTables(attributes()) && VerifyOffset(verifier, VT_DOCUMENTATION) &&
             verifier.VerifyVector(documentation()) && verifier.VerifyVectorOfStrings(documentation()) &&
             VerifyOffset(verifier, VT_DECLARATION_FILE) && verifier.VerifyString(declaration_file()) &&
             verifier.EndTable();
    }

    EnumT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(EnumT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static ::flatbuffers::Offset<Enum> Pack(
      ::flatbuffers::FlatBufferBuilder &_fbb, const EnumT *_o,
      const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
  };

  struct EnumBuilder {
    typedef Enum Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;

    void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
      fbb_.AddOffset(Enum::VT_NAME, name);
    }

    void add_values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::EnumVal>>> values) {
      fbb_.AddOffset(Enum::VT_VALUES, values);
    }

    void add_is_union(bool is_union) {
      fbb_.AddElement<uint8_t>(Enum::VT_IS_UNION, static_cast<uint8_t>(is_union), 0);
    }

    void add_underlying_type(::flatbuffers::Offset<reflection::Type> underlying_type) {
      fbb_.AddOffset(Enum::VT_UNDERLYING_TYPE, underlying_type);
    }

    void add_attributes(
      ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>>> attributes) {
      fbb_.AddOffset(Enum::VT_ATTRIBUTES, attributes);
    }

    void add_documentation(
      ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> documentation) {
      fbb_.AddOffset(Enum::VT_DOCUMENTATION, documentation);
    }

    void add_declaration_file(::flatbuffers::Offset<::flatbuffers::String> declaration_file) {
      fbb_.AddOffset(Enum::VT_DECLARATION_FILE, declaration_file);
    }

    explicit EnumBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
      start_ = fbb_.StartTable();
    }

    ::flatbuffers::Offset<Enum> Finish() {
      const auto end = fbb_.EndTable(start_);
      auto o = ::flatbuffers::Offset<Enum>(end);
      fbb_.Required(o, Enum::VT_NAME);
      fbb_.Required(o, Enum::VT_VALUES);
      fbb_.Required(o, Enum::VT_UNDERLYING_TYPE);
      return o;
    }
  };

  inline ::flatbuffers::Offset<Enum> CreateEnum(
    ::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::EnumVal>>> values = 0,
    bool is_union = false, ::flatbuffers::Offset<reflection::Type> underlying_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>>> attributes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> documentation = 0,
    ::flatbuffers::Offset<::flatbuffers::String> declaration_file = 0) {
    EnumBuilder builder_(_fbb);
    builder_.add_declaration_file(declaration_file);
    builder_.add_documentation(documentation);
    builder_.add_attributes(attributes);
    builder_.add_underlying_type(underlying_type);
    builder_.add_values(values);
    builder_.add_name(name);
    builder_.add_is_union(is_union);
    return builder_.Finish();
  }

  struct Enum::Traits {
    using type = Enum;
    static auto constexpr Create = CreateEnum;
    static constexpr auto name = "Enum";
    static constexpr auto fully_qualified_name = "reflection.Enum";
    static constexpr size_t fields_number = 7;
    static constexpr std::array<const char *, fields_number> field_names = {
      "name", "values", "is_union", "underlying_type", "attributes", "documentation", "declaration_file"
    };
    template <size_t Index>
    using FieldType = decltype(std::declval<type>().get_field<Index>());
  };

  inline ::flatbuffers::Offset<Enum> CreateEnumDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr,
    std::vector<::flatbuffers::Offset<reflection::EnumVal>> *values = nullptr, bool is_union = false,
    ::flatbuffers::Offset<reflection::Type> underlying_type = 0,
    std::vector<::flatbuffers::Offset<reflection::KeyValue>> *attributes = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *documentation = nullptr,
    const char *declaration_file = nullptr) {
    auto name__ = name ? _fbb.CreateString(name) : 0;
    auto values__ = values ? _fbb.CreateVectorOfSortedTables<reflection::EnumVal>(values) : 0;
    auto attributes__ = attributes ? _fbb.CreateVectorOfSortedTables<reflection::KeyValue>(attributes) : 0;
    auto documentation__ =
      documentation ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*documentation) : 0;
    auto declaration_file__ = declaration_file ? _fbb.CreateString(declaration_file) : 0;
    return reflection::CreateEnum(
      _fbb, name__, values__, is_union, underlying_type, attributes__, documentation__, declaration_file__);
  }

  ::flatbuffers::Offset<Enum> CreateEnum(
    ::flatbuffers::FlatBufferBuilder &_fbb, const EnumT *_o,
    const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

  struct FieldT : public ::flatbuffers::NativeTable {
    typedef Field TableType;

    static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
      return "reflection.FieldT";
    }

    std::string name{};
    std::unique_ptr<reflection::TypeT> type{};
    uint16_t id = 0;
    uint16_t offset = 0;
    int64_t default_integer = 0;
    double default_real = 0.0;
    bool deprecated = false;
    bool required = false;
    bool key = false;
    std::vector<std::unique_ptr<reflection::KeyValueT>> attributes{};
    std::vector<std::string> documentation{};
    bool optional = false;
    uint16_t padding = 0;
    bool offset64 = false;
    FieldT() = default;
    FieldT(const FieldT &o);
    FieldT(FieldT &&) FLATBUFFERS_NOEXCEPT = default;
    FieldT &operator=(FieldT o) FLATBUFFERS_NOEXCEPT;
  };

  struct Field FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef FieldT NativeTableType;
    typedef FieldBuilder Builder;
    struct Traits;

    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
      return FieldTypeTable();
    }

    static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
      return "reflection.Field";
    }

    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
      VT_NAME = 4,
      VT_TYPE = 6,
      VT_ID = 8,
      VT_OFFSET = 10,
      VT_DEFAULT_INTEGER = 12,
      VT_DEFAULT_REAL = 14,
      VT_DEPRECATED = 16,
      VT_REQUIRED = 18,
      VT_KEY = 20,
      VT_ATTRIBUTES = 22,
      VT_DOCUMENTATION = 24,
      VT_OPTIONAL = 26,
      VT_PADDING = 28,
      VT_OFFSET64 = 30
    };

    const ::flatbuffers::String *name() const {
      return GetPointer<const ::flatbuffers::String *>(VT_NAME);
    }

    ::flatbuffers::String *mutable_name() {
      return GetPointer<::flatbuffers::String *>(VT_NAME);
    }

    bool KeyCompareLessThan(const Field *const o) const {
      return *name() < *o->name();
    }

    int KeyCompareWithValue(const char *_name) const {
      return strcmp(name()->c_str(), _name);
    }

    template <typename StringType>
    int KeyCompareWithValue(const StringType &_name) const {
      if (name()->c_str() < _name)
        return -1;
      if (_name < name()->c_str())
        return 1;
      return 0;
    }

    const reflection::Type *type() const {
      return GetPointer<const reflection::Type *>(VT_TYPE);
    }

    reflection::Type *mutable_type() {
      return GetPointer<reflection::Type *>(VT_TYPE);
    }

    uint16_t id() const {
      return GetField<uint16_t>(VT_ID, 0);
    }

    bool mutate_id(uint16_t _id = 0) {
      return SetField<uint16_t>(VT_ID, _id, 0);
    }

    uint16_t offset() const {
      return GetField<uint16_t>(VT_OFFSET, 0);
    }

    bool mutate_offset(uint16_t _offset = 0) {
      return SetField<uint16_t>(VT_OFFSET, _offset, 0);
    }

    int64_t default_integer() const {
      return GetField<int64_t>(VT_DEFAULT_INTEGER, 0);
    }

    bool mutate_default_integer(int64_t _default_integer = 0) {
      return SetField<int64_t>(VT_DEFAULT_INTEGER, _default_integer, 0);
    }

    double default_real() const {
      return GetField<double>(VT_DEFAULT_REAL, 0.0);
    }

    bool mutate_default_real(double _default_real = 0.0) {
      return SetField<double>(VT_DEFAULT_REAL, _default_real, 0.0);
    }

    bool deprecated() const {
      return GetField<uint8_t>(VT_DEPRECATED, 0) != 0;
    }

    bool mutate_deprecated(bool _deprecated = 0) {
      return SetField<uint8_t>(VT_DEPRECATED, static_cast<uint8_t>(_deprecated), 0);
    }

    bool required() const {
      return GetField<uint8_t>(VT_REQUIRED, 0) != 0;
    }

    bool mutate_required(bool _required = 0) {
      return SetField<uint8_t>(VT_REQUIRED, static_cast<uint8_t>(_required), 0);
    }

    bool key() const {
      return GetField<uint8_t>(VT_KEY, 0) != 0;
    }

    bool mutate_key(bool _key = 0) {
      return SetField<uint8_t>(VT_KEY, static_cast<uint8_t>(_key), 0);
    }

    const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *attributes() const {
      return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *>(VT_ATTRIBUTES);
    }

    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *mutable_attributes() {
      return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *>(VT_ATTRIBUTES);
    }

    const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *documentation() const {
      return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DOCUMENTATION);
    }

    ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_documentation() {
      return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DOCUMENTATION);
    }

    bool optional() const {
      return GetField<uint8_t>(VT_OPTIONAL, 0) != 0;
    }

    bool mutate_optional(bool _optional = 0) {
      return SetField<uint8_t>(VT_OPTIONAL, static_cast<uint8_t>(_optional), 0);
    }

    /// Number of padding octets to always add after this field. Structs only.
    uint16_t padding() const {
      return GetField<uint16_t>(VT_PADDING, 0);
    }

    bool mutate_padding(uint16_t _padding = 0) {
      return SetField<uint16_t>(VT_PADDING, _padding, 0);
    }

    /// If the field uses 64-bit offsets.
    bool offset64() const {
      return GetField<uint8_t>(VT_OFFSET64, 0) != 0;
    }

    bool mutate_offset64(bool _offset64 = 0) {
      return SetField<uint8_t>(VT_OFFSET64, static_cast<uint8_t>(_offset64), 0);
    }

    template <size_t Index>
    auto get_field() const {
      if constexpr (Index == 0)
        return name();
      else if constexpr (Index == 1)
        return type();
      else if constexpr (Index == 2)
        return id();
      else if constexpr (Index == 3)
        return offset();
      else if constexpr (Index == 4)
        return default_integer();
      else if constexpr (Index == 5)
        return default_real();
      else if constexpr (Index == 6)
        return deprecated();
      else if constexpr (Index == 7)
        return required();
      else if constexpr (Index == 8)
        return key();
      else if constexpr (Index == 9)
        return attributes();
      else if constexpr (Index == 10)
        return documentation();
      else if constexpr (Index == 11)
        return optional();
      else if constexpr (Index == 12)
        return padding();
      else if constexpr (Index == 13)
        return offset64();
      else
        static_assert(Index != Index, "Invalid Field Index");
    }

    bool Verify(::flatbuffers::Verifier &verifier) const {
      return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_NAME) && verifier.VerifyString(name()) &&
             VerifyOffsetRequired(verifier, VT_TYPE) && verifier.VerifyTable(type()) &&
             VerifyField<uint16_t>(verifier, VT_ID, 2) && VerifyField<uint16_t>(verifier, VT_OFFSET, 2) &&
             VerifyField<int64_t>(verifier, VT_DEFAULT_INTEGER, 8) &&
             VerifyField<double>(verifier, VT_DEFAULT_REAL, 8) && VerifyField<uint8_t>(verifier, VT_DEPRECATED, 1) &&
             VerifyField<uint8_t>(verifier, VT_REQUIRED, 1) && VerifyField<uint8_t>(verifier, VT_KEY, 1) &&
             VerifyOffset(verifier, VT_ATTRIBUTES) && verifier.VerifyVector(attributes()) &&
             verifier.VerifyVectorOfTables(attributes()) && VerifyOffset(verifier, VT_DOCUMENTATION) &&
             verifier.VerifyVector(documentation()) && verifier.VerifyVectorOfStrings(documentation()) &&
             VerifyField<uint8_t>(verifier, VT_OPTIONAL, 1) && VerifyField<uint16_t>(verifier, VT_PADDING, 2) &&
             VerifyField<uint8_t>(verifier, VT_OFFSET64, 1) && verifier.EndTable();
    }

    FieldT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(FieldT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static ::flatbuffers::Offset<Field> Pack(
      ::flatbuffers::FlatBufferBuilder &_fbb, const FieldT *_o,
      const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
  };

  struct FieldBuilder {
    typedef Field Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;

    void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
      fbb_.AddOffset(Field::VT_NAME, name);
    }

    void add_type(::flatbuffers::Offset<reflection::Type> type) {
      fbb_.AddOffset(Field::VT_TYPE, type);
    }

    void add_id(uint16_t id) {
      fbb_.AddElement<uint16_t>(Field::VT_ID, id, 0);
    }

    void add_offset(uint16_t offset) {
      fbb_.AddElement<uint16_t>(Field::VT_OFFSET, offset, 0);
    }

    void add_default_integer(int64_t default_integer) {
      fbb_.AddElement<int64_t>(Field::VT_DEFAULT_INTEGER, default_integer, 0);
    }

    void add_default_real(double default_real) {
      fbb_.AddElement<double>(Field::VT_DEFAULT_REAL, default_real, 0.0);
    }

    void add_deprecated(bool deprecated) {
      fbb_.AddElement<uint8_t>(Field::VT_DEPRECATED, static_cast<uint8_t>(deprecated), 0);
    }

    void add_required(bool required) {
      fbb_.AddElement<uint8_t>(Field::VT_REQUIRED, static_cast<uint8_t>(required), 0);
    }

    void add_key(bool key) {
      fbb_.AddElement<uint8_t>(Field::VT_KEY, static_cast<uint8_t>(key), 0);
    }

    void add_attributes(
      ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>>> attributes) {
      fbb_.AddOffset(Field::VT_ATTRIBUTES, attributes);
    }

    void add_documentation(
      ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> documentation) {
      fbb_.AddOffset(Field::VT_DOCUMENTATION, documentation);
    }

    void add_optional(bool optional) {
      fbb_.AddElement<uint8_t>(Field::VT_OPTIONAL, static_cast<uint8_t>(optional), 0);
    }

    void add_padding(uint16_t padding) {
      fbb_.AddElement<uint16_t>(Field::VT_PADDING, padding, 0);
    }

    void add_offset64(bool offset64) {
      fbb_.AddElement<uint8_t>(Field::VT_OFFSET64, static_cast<uint8_t>(offset64), 0);
    }

    explicit FieldBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
      start_ = fbb_.StartTable();
    }

    ::flatbuffers::Offset<Field> Finish() {
      const auto end = fbb_.EndTable(start_);
      auto o = ::flatbuffers::Offset<Field>(end);
      fbb_.Required(o, Field::VT_NAME);
      fbb_.Required(o, Field::VT_TYPE);
      return o;
    }
  };

  inline ::flatbuffers::Offset<Field> CreateField(
    ::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<reflection::Type> type = 0, uint16_t id = 0, uint16_t offset = 0, int64_t default_integer = 0,
    double default_real = 0.0, bool deprecated = false, bool required = false, bool key = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>>> attributes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> documentation = 0,
    bool optional = false, uint16_t padding = 0, bool offset64 = false) {
    FieldBuilder builder_(_fbb);
    builder_.add_default_real(default_real);
    builder_.add_default_integer(default_integer);
    builder_.add_documentation(documentation);
    builder_.add_attributes(attributes);
    builder_.add_type(type);
    builder_.add_name(name);
    builder_.add_padding(padding);
    builder_.add_offset(offset);
    builder_.add_id(id);
    builder_.add_offset64(offset64);
    builder_.add_optional(optional);
    builder_.add_key(key);
    builder_.add_required(required);
    builder_.add_deprecated(deprecated);
    return builder_.Finish();
  }

  struct Field::Traits {
    using type = Field;
    static auto constexpr Create = CreateField;
    static constexpr auto name = "Field";
    static constexpr auto fully_qualified_name = "reflection.Field";
    static constexpr size_t fields_number = 14;
    static constexpr std::array<const char *, fields_number> field_names = {
      "name",     "type", "id",         "offset",        "default_integer", "default_real", "deprecated",
      "required", "key",  "attributes", "documentation", "optional",        "padding",      "offset64"
    };
    template <size_t Index>
    using FieldType = decltype(std::declval<type>().get_field<Index>());
  };

  inline ::flatbuffers::Offset<Field> CreateFieldDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr,
    ::flatbuffers::Offset<reflection::Type> type = 0, uint16_t id = 0, uint16_t offset = 0, int64_t default_integer = 0,
    double default_real = 0.0, bool deprecated = false, bool required = false, bool key = false,
    std::vector<::flatbuffers::Offset<reflection::KeyValue>> *attributes = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *documentation = nullptr, bool optional = false,
    uint16_t padding = 0, bool offset64 = false) {
    auto name__ = name ? _fbb.CreateString(name) : 0;
    auto attributes__ = attributes ? _fbb.CreateVectorOfSortedTables<reflection::KeyValue>(attributes) : 0;
    auto documentation__ =
      documentation ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*documentation) : 0;
    return reflection::CreateField(
      _fbb, name__, type, id, offset, default_integer, default_real, deprecated, required, key, attributes__,
      documentation__, optional, padding, offset64);
  }

  ::flatbuffers::Offset<Field> CreateField(
    ::flatbuffers::FlatBufferBuilder &_fbb, const FieldT *_o,
    const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

  struct ObjectT : public ::flatbuffers::NativeTable {
    typedef Object TableType;

    static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
      return "reflection.ObjectT";
    }

    std::string name{};
    std::vector<std::unique_ptr<reflection::FieldT>> fields{};
    bool is_struct = false;
    int32_t minalign = 0;
    int32_t bytesize = 0;
    std::vector<std::unique_ptr<reflection::KeyValueT>> attributes{};
    std::vector<std::string> documentation{};
    std::string declaration_file{};
    ObjectT() = default;
    ObjectT(const ObjectT &o);
    ObjectT(ObjectT &&) FLATBUFFERS_NOEXCEPT = default;
    ObjectT &operator=(ObjectT o) FLATBUFFERS_NOEXCEPT;
  };

  struct Object FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef ObjectT NativeTableType;
    typedef ObjectBuilder Builder;
    struct Traits;

    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
      return ObjectTypeTable();
    }

    static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
      return "reflection.Object";
    }

    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
      VT_NAME = 4,
      VT_FIELDS = 6,
      VT_IS_STRUCT = 8,
      VT_MINALIGN = 10,
      VT_BYTESIZE = 12,
      VT_ATTRIBUTES = 14,
      VT_DOCUMENTATION = 16,
      VT_DECLARATION_FILE = 18
    };

    const ::flatbuffers::String *name() const {
      return GetPointer<const ::flatbuffers::String *>(VT_NAME);
    }

    ::flatbuffers::String *mutable_name() {
      return GetPointer<::flatbuffers::String *>(VT_NAME);
    }

    bool KeyCompareLessThan(const Object *const o) const {
      return *name() < *o->name();
    }

    int KeyCompareWithValue(const char *_name) const {
      return strcmp(name()->c_str(), _name);
    }

    template <typename StringType>
    int KeyCompareWithValue(const StringType &_name) const {
      if (name()->c_str() < _name)
        return -1;
      if (_name < name()->c_str())
        return 1;
      return 0;
    }

    const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Field>> *fields() const {
      return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Field>> *>(VT_FIELDS);
    }

    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Field>> *mutable_fields() {
      return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<reflection::Field>> *>(VT_FIELDS);
    }

    bool is_struct() const {
      return GetField<uint8_t>(VT_IS_STRUCT, 0) != 0;
    }

    bool mutate_is_struct(bool _is_struct = 0) {
      return SetField<uint8_t>(VT_IS_STRUCT, static_cast<uint8_t>(_is_struct), 0);
    }

    int32_t minalign() const {
      return GetField<int32_t>(VT_MINALIGN, 0);
    }

    bool mutate_minalign(int32_t _minalign = 0) {
      return SetField<int32_t>(VT_MINALIGN, _minalign, 0);
    }

    int32_t bytesize() const {
      return GetField<int32_t>(VT_BYTESIZE, 0);
    }

    bool mutate_bytesize(int32_t _bytesize = 0) {
      return SetField<int32_t>(VT_BYTESIZE, _bytesize, 0);
    }

    const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *attributes() const {
      return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *>(VT_ATTRIBUTES);
    }

    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *mutable_attributes() {
      return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *>(VT_ATTRIBUTES);
    }

    const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *documentation() const {
      return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DOCUMENTATION);
    }

    ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_documentation() {
      return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DOCUMENTATION);
    }

    /// File that this Object is declared in.
    const ::flatbuffers::String *declaration_file() const {
      return GetPointer<const ::flatbuffers::String *>(VT_DECLARATION_FILE);
    }

    ::flatbuffers::String *mutable_declaration_file() {
      return GetPointer<::flatbuffers::String *>(VT_DECLARATION_FILE);
    }

    template <size_t Index>
    auto get_field() const {
      if constexpr (Index == 0)
        return name();
      else if constexpr (Index == 1)
        return fields();
      else if constexpr (Index == 2)
        return is_struct();
      else if constexpr (Index == 3)
        return minalign();
      else if constexpr (Index == 4)
        return bytesize();
      else if constexpr (Index == 5)
        return attributes();
      else if constexpr (Index == 6)
        return documentation();
      else if constexpr (Index == 7)
        return declaration_file();
      else
        static_assert(Index != Index, "Invalid Field Index");
    }

    bool Verify(::flatbuffers::Verifier &verifier) const {
      return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_NAME) && verifier.VerifyString(name()) &&
             VerifyOffsetRequired(verifier, VT_FIELDS) && verifier.VerifyVector(fields()) &&
             verifier.VerifyVectorOfTables(fields()) && VerifyField<uint8_t>(verifier, VT_IS_STRUCT, 1) &&
             VerifyField<int32_t>(verifier, VT_MINALIGN, 4) && VerifyField<int32_t>(verifier, VT_BYTESIZE, 4) &&
             VerifyOffset(verifier, VT_ATTRIBUTES) && verifier.VerifyVector(attributes()) &&
             verifier.VerifyVectorOfTables(attributes()) && VerifyOffset(verifier, VT_DOCUMENTATION) &&
             verifier.VerifyVector(documentation()) && verifier.VerifyVectorOfStrings(documentation()) &&
             VerifyOffset(verifier, VT_DECLARATION_FILE) && verifier.VerifyString(declaration_file()) &&
             verifier.EndTable();
    }

    ObjectT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ObjectT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static ::flatbuffers::Offset<Object> Pack(
      ::flatbuffers::FlatBufferBuilder &_fbb, const ObjectT *_o,
      const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
  };

  struct ObjectBuilder {
    typedef Object Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;

    void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
      fbb_.AddOffset(Object::VT_NAME, name);
    }

    void add_fields(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::Field>>> fields) {
      fbb_.AddOffset(Object::VT_FIELDS, fields);
    }

    void add_is_struct(bool is_struct) {
      fbb_.AddElement<uint8_t>(Object::VT_IS_STRUCT, static_cast<uint8_t>(is_struct), 0);
    }

    void add_minalign(int32_t minalign) {
      fbb_.AddElement<int32_t>(Object::VT_MINALIGN, minalign, 0);
    }

    void add_bytesize(int32_t bytesize) {
      fbb_.AddElement<int32_t>(Object::VT_BYTESIZE, bytesize, 0);
    }

    void add_attributes(
      ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>>> attributes) {
      fbb_.AddOffset(Object::VT_ATTRIBUTES, attributes);
    }

    void add_documentation(
      ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> documentation) {
      fbb_.AddOffset(Object::VT_DOCUMENTATION, documentation);
    }

    void add_declaration_file(::flatbuffers::Offset<::flatbuffers::String> declaration_file) {
      fbb_.AddOffset(Object::VT_DECLARATION_FILE, declaration_file);
    }

    explicit ObjectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
      start_ = fbb_.StartTable();
    }

    ::flatbuffers::Offset<Object> Finish() {
      const auto end = fbb_.EndTable(start_);
      auto o = ::flatbuffers::Offset<Object>(end);
      fbb_.Required(o, Object::VT_NAME);
      fbb_.Required(o, Object::VT_FIELDS);
      return o;
    }
  };

  inline ::flatbuffers::Offset<Object> CreateObject(
    ::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::Field>>> fields = 0,
    bool is_struct = false, int32_t minalign = 0, int32_t bytesize = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>>> attributes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> documentation = 0,
    ::flatbuffers::Offset<::flatbuffers::String> declaration_file = 0) {
    ObjectBuilder builder_(_fbb);
    builder_.add_declaration_file(declaration_file);
    builder_.add_documentation(documentation);
    builder_.add_attributes(attributes);
    builder_.add_bytesize(bytesize);
    builder_.add_minalign(minalign);
    builder_.add_fields(fields);
    builder_.add_name(name);
    builder_.add_is_struct(is_struct);
    return builder_.Finish();
  }

  struct Object::Traits {
    using type = Object;
    static auto constexpr Create = CreateObject;
    static constexpr auto name = "Object";
    static constexpr auto fully_qualified_name = "reflection.Object";
    static constexpr size_t fields_number = 8;
    static constexpr std::array<const char *, fields_number> field_names = {
      "name", "fields", "is_struct", "minalign", "bytesize", "attributes", "documentation", "declaration_file"
    };
    template <size_t Index>
    using FieldType = decltype(std::declval<type>().get_field<Index>());
  };

  inline ::flatbuffers::Offset<Object> CreateObjectDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr,
    std::vector<::flatbuffers::Offset<reflection::Field>> *fields = nullptr, bool is_struct = false,
    int32_t minalign = 0, int32_t bytesize = 0,
    std::vector<::flatbuffers::Offset<reflection::KeyValue>> *attributes = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *documentation = nullptr,
    const char *declaration_file = nullptr) {
    auto name__ = name ? _fbb.CreateString(name) : 0;
    auto fields__ = fields ? _fbb.CreateVectorOfSortedTables<reflection::Field>(fields) : 0;
    auto attributes__ = attributes ? _fbb.CreateVectorOfSortedTables<reflection::KeyValue>(attributes) : 0;
    auto documentation__ =
      documentation ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*documentation) : 0;
    auto declaration_file__ = declaration_file ? _fbb.CreateString(declaration_file) : 0;
    return reflection::CreateObject(
      _fbb, name__, fields__, is_struct, minalign, bytesize, attributes__, documentation__, declaration_file__);
  }

  ::flatbuffers::Offset<Object> CreateObject(
    ::flatbuffers::FlatBufferBuilder &_fbb, const ObjectT *_o,
    const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

  struct RPCCallT : public ::flatbuffers::NativeTable {
    typedef RPCCall TableType;

    static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
      return "reflection.RPCCallT";
    }

    std::string name{};
    std::unique_ptr<reflection::ObjectT> request{};
    std::unique_ptr<reflection::ObjectT> response{};
    std::vector<std::unique_ptr<reflection::KeyValueT>> attributes{};
    std::vector<std::string> documentation{};
    RPCCallT() = default;
    RPCCallT(const RPCCallT &o);
    RPCCallT(RPCCallT &&) FLATBUFFERS_NOEXCEPT = default;
    RPCCallT &operator=(RPCCallT o) FLATBUFFERS_NOEXCEPT;
  };

  struct RPCCall FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef RPCCallT NativeTableType;
    typedef RPCCallBuilder Builder;
    struct Traits;

    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
      return RPCCallTypeTable();
    }

    static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
      return "reflection.RPCCall";
    }

    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
      VT_NAME = 4,
      VT_REQUEST = 6,
      VT_RESPONSE = 8,
      VT_ATTRIBUTES = 10,
      VT_DOCUMENTATION = 12
    };

    const ::flatbuffers::String *name() const {
      return GetPointer<const ::flatbuffers::String *>(VT_NAME);
    }

    ::flatbuffers::String *mutable_name() {
      return GetPointer<::flatbuffers::String *>(VT_NAME);
    }

    bool KeyCompareLessThan(const RPCCall *const o) const {
      return *name() < *o->name();
    }

    int KeyCompareWithValue(const char *_name) const {
      return strcmp(name()->c_str(), _name);
    }

    template <typename StringType>
    int KeyCompareWithValue(const StringType &_name) const {
      if (name()->c_str() < _name)
        return -1;
      if (_name < name()->c_str())
        return 1;
      return 0;
    }

    const reflection::Object *request() const {
      return GetPointer<const reflection::Object *>(VT_REQUEST);
    }

    reflection::Object *mutable_request() {
      return GetPointer<reflection::Object *>(VT_REQUEST);
    }

    const reflection::Object *response() const {
      return GetPointer<const reflection::Object *>(VT_RESPONSE);
    }

    reflection::Object *mutable_response() {
      return GetPointer<reflection::Object *>(VT_RESPONSE);
    }

    const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *attributes() const {
      return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *>(VT_ATTRIBUTES);
    }

    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *mutable_attributes() {
      return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *>(VT_ATTRIBUTES);
    }

    const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *documentation() const {
      return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DOCUMENTATION);
    }

    ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_documentation() {
      return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DOCUMENTATION);
    }

    template <size_t Index>
    auto get_field() const {
      if constexpr (Index == 0)
        return name();
      else if constexpr (Index == 1)
        return request();
      else if constexpr (Index == 2)
        return response();
      else if constexpr (Index == 3)
        return attributes();
      else if constexpr (Index == 4)
        return documentation();
      else
        static_assert(Index != Index, "Invalid Field Index");
    }

    bool Verify(::flatbuffers::Verifier &verifier) const {
      return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_NAME) && verifier.VerifyString(name()) &&
             VerifyOffsetRequired(verifier, VT_REQUEST) && verifier.VerifyTable(request()) &&
             VerifyOffsetRequired(verifier, VT_RESPONSE) && verifier.VerifyTable(response()) &&
             VerifyOffset(verifier, VT_ATTRIBUTES) && verifier.VerifyVector(attributes()) &&
             verifier.VerifyVectorOfTables(attributes()) && VerifyOffset(verifier, VT_DOCUMENTATION) &&
             verifier.VerifyVector(documentation()) && verifier.VerifyVectorOfStrings(documentation()) &&
             verifier.EndTable();
    }

    RPCCallT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(RPCCallT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static ::flatbuffers::Offset<RPCCall> Pack(
      ::flatbuffers::FlatBufferBuilder &_fbb, const RPCCallT *_o,
      const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
  };

  struct RPCCallBuilder {
    typedef RPCCall Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;

    void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
      fbb_.AddOffset(RPCCall::VT_NAME, name);
    }

    void add_request(::flatbuffers::Offset<reflection::Object> request) {
      fbb_.AddOffset(RPCCall::VT_REQUEST, request);
    }

    void add_response(::flatbuffers::Offset<reflection::Object> response) {
      fbb_.AddOffset(RPCCall::VT_RESPONSE, response);
    }

    void add_attributes(
      ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>>> attributes) {
      fbb_.AddOffset(RPCCall::VT_ATTRIBUTES, attributes);
    }

    void add_documentation(
      ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> documentation) {
      fbb_.AddOffset(RPCCall::VT_DOCUMENTATION, documentation);
    }

    explicit RPCCallBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
      start_ = fbb_.StartTable();
    }

    ::flatbuffers::Offset<RPCCall> Finish() {
      const auto end = fbb_.EndTable(start_);
      auto o = ::flatbuffers::Offset<RPCCall>(end);
      fbb_.Required(o, RPCCall::VT_NAME);
      fbb_.Required(o, RPCCall::VT_REQUEST);
      fbb_.Required(o, RPCCall::VT_RESPONSE);
      return o;
    }
  };

  inline ::flatbuffers::Offset<RPCCall> CreateRPCCall(
    ::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<reflection::Object> request = 0, ::flatbuffers::Offset<reflection::Object> response = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>>> attributes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> documentation = 0) {
    RPCCallBuilder builder_(_fbb);
    builder_.add_documentation(documentation);
    builder_.add_attributes(attributes);
    builder_.add_response(response);
    builder_.add_request(request);
    builder_.add_name(name);
    return builder_.Finish();
  }

  struct RPCCall::Traits {
    using type = RPCCall;
    static auto constexpr Create = CreateRPCCall;
    static constexpr auto name = "RPCCall";
    static constexpr auto fully_qualified_name = "reflection.RPCCall";
    static constexpr size_t fields_number = 5;
    static constexpr std::array<const char *, fields_number> field_names = { "name", "request", "response",
                                                                             "attributes", "documentation" };
    template <size_t Index>
    using FieldType = decltype(std::declval<type>().get_field<Index>());
  };

  inline ::flatbuffers::Offset<RPCCall> CreateRPCCallDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr,
    ::flatbuffers::Offset<reflection::Object> request = 0, ::flatbuffers::Offset<reflection::Object> response = 0,
    std::vector<::flatbuffers::Offset<reflection::KeyValue>> *attributes = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *documentation = nullptr) {
    auto name__ = name ? _fbb.CreateString(name) : 0;
    auto attributes__ = attributes ? _fbb.CreateVectorOfSortedTables<reflection::KeyValue>(attributes) : 0;
    auto documentation__ =
      documentation ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*documentation) : 0;
    return reflection::CreateRPCCall(_fbb, name__, request, response, attributes__, documentation__);
  }

  ::flatbuffers::Offset<RPCCall> CreateRPCCall(
    ::flatbuffers::FlatBufferBuilder &_fbb, const RPCCallT *_o,
    const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

  struct ServiceT : public ::flatbuffers::NativeTable {
    typedef Service TableType;

    static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
      return "reflection.ServiceT";
    }

    std::string name{};
    std::vector<std::unique_ptr<reflection::RPCCallT>> calls{};
    std::vector<std::unique_ptr<reflection::KeyValueT>> attributes{};
    std::vector<std::string> documentation{};
    std::string declaration_file{};
    ServiceT() = default;
    ServiceT(const ServiceT &o);
    ServiceT(ServiceT &&) FLATBUFFERS_NOEXCEPT = default;
    ServiceT &operator=(ServiceT o) FLATBUFFERS_NOEXCEPT;
  };

  struct Service FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef ServiceT NativeTableType;
    typedef ServiceBuilder Builder;
    struct Traits;

    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
      return ServiceTypeTable();
    }

    static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
      return "reflection.Service";
    }

    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
      VT_NAME = 4,
      VT_CALLS = 6,
      VT_ATTRIBUTES = 8,
      VT_DOCUMENTATION = 10,
      VT_DECLARATION_FILE = 12
    };

    const ::flatbuffers::String *name() const {
      return GetPointer<const ::flatbuffers::String *>(VT_NAME);
    }

    ::flatbuffers::String *mutable_name() {
      return GetPointer<::flatbuffers::String *>(VT_NAME);
    }

    bool KeyCompareLessThan(const Service *const o) const {
      return *name() < *o->name();
    }

    int KeyCompareWithValue(const char *_name) const {
      return strcmp(name()->c_str(), _name);
    }

    template <typename StringType>
    int KeyCompareWithValue(const StringType &_name) const {
      if (name()->c_str() < _name)
        return -1;
      if (_name < name()->c_str())
        return 1;
      return 0;
    }

    const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::RPCCall>> *calls() const {
      return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::RPCCall>> *>(VT_CALLS);
    }

    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::RPCCall>> *mutable_calls() {
      return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<reflection::RPCCall>> *>(VT_CALLS);
    }

    const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *attributes() const {
      return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *>(VT_ATTRIBUTES);
    }

    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *mutable_attributes() {
      return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>> *>(VT_ATTRIBUTES);
    }

    const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *documentation() const {
      return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DOCUMENTATION);
    }

    ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_documentation() {
      return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DOCUMENTATION);
    }

    /// File that this Service is declared in.
    const ::flatbuffers::String *declaration_file() const {
      return GetPointer<const ::flatbuffers::String *>(VT_DECLARATION_FILE);
    }

    ::flatbuffers::String *mutable_declaration_file() {
      return GetPointer<::flatbuffers::String *>(VT_DECLARATION_FILE);
    }

    template <size_t Index>
    auto get_field() const {
      if constexpr (Index == 0)
        return name();
      else if constexpr (Index == 1)
        return calls();
      else if constexpr (Index == 2)
        return attributes();
      else if constexpr (Index == 3)
        return documentation();
      else if constexpr (Index == 4)
        return declaration_file();
      else
        static_assert(Index != Index, "Invalid Field Index");
    }

    bool Verify(::flatbuffers::Verifier &verifier) const {
      return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_NAME) && verifier.VerifyString(name()) &&
             VerifyOffset(verifier, VT_CALLS) && verifier.VerifyVector(calls()) &&
             verifier.VerifyVectorOfTables(calls()) && VerifyOffset(verifier, VT_ATTRIBUTES) &&
             verifier.VerifyVector(attributes()) && verifier.VerifyVectorOfTables(attributes()) &&
             VerifyOffset(verifier, VT_DOCUMENTATION) && verifier.VerifyVector(documentation()) &&
             verifier.VerifyVectorOfStrings(documentation()) && VerifyOffset(verifier, VT_DECLARATION_FILE) &&
             verifier.VerifyString(declaration_file()) && verifier.EndTable();
    }

    ServiceT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ServiceT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static ::flatbuffers::Offset<Service> Pack(
      ::flatbuffers::FlatBufferBuilder &_fbb, const ServiceT *_o,
      const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
  };

  struct ServiceBuilder {
    typedef Service Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;

    void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
      fbb_.AddOffset(Service::VT_NAME, name);
    }

    void add_calls(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::RPCCall>>> calls) {
      fbb_.AddOffset(Service::VT_CALLS, calls);
    }

    void add_attributes(
      ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>>> attributes) {
      fbb_.AddOffset(Service::VT_ATTRIBUTES, attributes);
    }

    void add_documentation(
      ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> documentation) {
      fbb_.AddOffset(Service::VT_DOCUMENTATION, documentation);
    }

    void add_declaration_file(::flatbuffers::Offset<::flatbuffers::String> declaration_file) {
      fbb_.AddOffset(Service::VT_DECLARATION_FILE, declaration_file);
    }

    explicit ServiceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
      start_ = fbb_.StartTable();
    }

    ::flatbuffers::Offset<Service> Finish() {
      const auto end = fbb_.EndTable(start_);
      auto o = ::flatbuffers::Offset<Service>(end);
      fbb_.Required(o, Service::VT_NAME);
      return o;
    }
  };

  inline ::flatbuffers::Offset<Service> CreateService(
    ::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::RPCCall>>> calls = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::KeyValue>>> attributes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> documentation = 0,
    ::flatbuffers::Offset<::flatbuffers::String> declaration_file = 0) {
    ServiceBuilder builder_(_fbb);
    builder_.add_declaration_file(declaration_file);
    builder_.add_documentation(documentation);
    builder_.add_attributes(attributes);
    builder_.add_calls(calls);
    builder_.add_name(name);
    return builder_.Finish();
  }

  struct Service::Traits {
    using type = Service;
    static auto constexpr Create = CreateService;
    static constexpr auto name = "Service";
    static constexpr auto fully_qualified_name = "reflection.Service";
    static constexpr size_t fields_number = 5;
    static constexpr std::array<const char *, fields_number> field_names = { "name", "calls", "attributes",
                                                                             "documentation", "declaration_file" };
    template <size_t Index>
    using FieldType = decltype(std::declval<type>().get_field<Index>());
  };

  inline ::flatbuffers::Offset<Service> CreateServiceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr,
    std::vector<::flatbuffers::Offset<reflection::RPCCall>> *calls = nullptr,
    std::vector<::flatbuffers::Offset<reflection::KeyValue>> *attributes = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *documentation = nullptr,
    const char *declaration_file = nullptr) {
    auto name__ = name ? _fbb.CreateString(name) : 0;
    auto calls__ = calls ? _fbb.CreateVectorOfSortedTables<reflection::RPCCall>(calls) : 0;
    auto attributes__ = attributes ? _fbb.CreateVectorOfSortedTables<reflection::KeyValue>(attributes) : 0;
    auto documentation__ =
      documentation ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*documentation) : 0;
    auto declaration_file__ = declaration_file ? _fbb.CreateString(declaration_file) : 0;
    return reflection::CreateService(_fbb, name__, calls__, attributes__, documentation__, declaration_file__);
  }

  ::flatbuffers::Offset<Service> CreateService(
    ::flatbuffers::FlatBufferBuilder &_fbb, const ServiceT *_o,
    const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

  struct SchemaFileT : public ::flatbuffers::NativeTable {
    typedef SchemaFile TableType;

    static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
      return "reflection.SchemaFileT";
    }

    std::string filename{};
    std::vector<std::string> included_filenames{};
  };

  /// File specific information.
  /// Symbols declared within a file may be recovered by iterating over all
  /// symbols and examining the `declaration_file` field.
  struct SchemaFile FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef SchemaFileT NativeTableType;
    typedef SchemaFileBuilder Builder;
    struct Traits;

    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
      return SchemaFileTypeTable();
    }

    static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
      return "reflection.SchemaFile";
    }

    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
      VT_FILENAME = 4,
      VT_INCLUDED_FILENAMES = 6
    };

    /// Filename, relative to project root.
    const ::flatbuffers::String *filename() const {
      return GetPointer<const ::flatbuffers::String *>(VT_FILENAME);
    }

    ::flatbuffers::String *mutable_filename() {
      return GetPointer<::flatbuffers::String *>(VT_FILENAME);
    }

    bool KeyCompareLessThan(const SchemaFile *const o) const {
      return *filename() < *o->filename();
    }

    int KeyCompareWithValue(const char *_filename) const {
      return strcmp(filename()->c_str(), _filename);
    }

    template <typename StringType>
    int KeyCompareWithValue(const StringType &_filename) const {
      if (filename()->c_str() < _filename)
        return -1;
      if (_filename < filename()->c_str())
        return 1;
      return 0;
    }

    /// Names of included files, relative to project root.
    const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *included_filenames() const {
      return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(
        VT_INCLUDED_FILENAMES);
    }

    ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_included_filenames() {
      return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_INCLUDED_FILENAMES);
    }

    template <size_t Index>
    auto get_field() const {
      if constexpr (Index == 0)
        return filename();
      else if constexpr (Index == 1)
        return included_filenames();
      else
        static_assert(Index != Index, "Invalid Field Index");
    }

    bool Verify(::flatbuffers::Verifier &verifier) const {
      return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_FILENAME) &&
             verifier.VerifyString(filename()) && VerifyOffset(verifier, VT_INCLUDED_FILENAMES) &&
             verifier.VerifyVector(included_filenames()) && verifier.VerifyVectorOfStrings(included_filenames()) &&
             verifier.EndTable();
    }

    SchemaFileT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SchemaFileT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static ::flatbuffers::Offset<SchemaFile> Pack(
      ::flatbuffers::FlatBufferBuilder &_fbb, const SchemaFileT *_o,
      const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
  };

  struct SchemaFileBuilder {
    typedef SchemaFile Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;

    void add_filename(::flatbuffers::Offset<::flatbuffers::String> filename) {
      fbb_.AddOffset(SchemaFile::VT_FILENAME, filename);
    }

    void add_included_filenames(
      ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> included_filenames) {
      fbb_.AddOffset(SchemaFile::VT_INCLUDED_FILENAMES, included_filenames);
    }

    explicit SchemaFileBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
      start_ = fbb_.StartTable();
    }

    ::flatbuffers::Offset<SchemaFile> Finish() {
      const auto end = fbb_.EndTable(start_);
      auto o = ::flatbuffers::Offset<SchemaFile>(end);
      fbb_.Required(o, SchemaFile::VT_FILENAME);
      return o;
    }
  };

  inline ::flatbuffers::Offset<SchemaFile> CreateSchemaFile(
    ::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::String> filename = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> included_filenames = 0) {
    SchemaFileBuilder builder_(_fbb);
    builder_.add_included_filenames(included_filenames);
    builder_.add_filename(filename);
    return builder_.Finish();
  }

  struct SchemaFile::Traits {
    using type = SchemaFile;
    static auto constexpr Create = CreateSchemaFile;
    static constexpr auto name = "SchemaFile";
    static constexpr auto fully_qualified_name = "reflection.SchemaFile";
    static constexpr size_t fields_number = 2;
    static constexpr std::array<const char *, fields_number> field_names = { "filename", "included_filenames" };
    template <size_t Index>
    using FieldType = decltype(std::declval<type>().get_field<Index>());
  };

  inline ::flatbuffers::Offset<SchemaFile> CreateSchemaFileDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, const char *filename = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *included_filenames = nullptr) {
    auto filename__ = filename ? _fbb.CreateString(filename) : 0;
    auto included_filenames__ =
      included_filenames ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*included_filenames) : 0;
    return reflection::CreateSchemaFile(_fbb, filename__, included_filenames__);
  }

  ::flatbuffers::Offset<SchemaFile> CreateSchemaFile(
    ::flatbuffers::FlatBufferBuilder &_fbb, const SchemaFileT *_o,
    const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

  struct SchemaT : public ::flatbuffers::NativeTable {
    typedef Schema TableType;

    static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
      return "reflection.SchemaT";
    }

    std::vector<std::unique_ptr<reflection::ObjectT>> objects{};
    std::vector<std::unique_ptr<reflection::EnumT>> enums{};
    std::string file_ident{};
    std::string file_ext{};
    std::unique_ptr<reflection::ObjectT> root_table{};
    std::vector<std::unique_ptr<reflection::ServiceT>> services{};
    reflection::AdvancedFeatures advanced_features = static_cast<reflection::AdvancedFeatures>(0);
    std::vector<std::unique_ptr<reflection::SchemaFileT>> fbs_files{};
    SchemaT() = default;
    SchemaT(const SchemaT &o);
    SchemaT(SchemaT &&) FLATBUFFERS_NOEXCEPT = default;
    SchemaT &operator=(SchemaT o) FLATBUFFERS_NOEXCEPT;
  };

  struct Schema FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef SchemaT NativeTableType;
    typedef SchemaBuilder Builder;
    struct Traits;

    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
      return SchemaTypeTable();
    }

    static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
      return "reflection.Schema";
    }

    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
      VT_OBJECTS = 4,
      VT_ENUMS = 6,
      VT_FILE_IDENT = 8,
      VT_FILE_EXT = 10,
      VT_ROOT_TABLE = 12,
      VT_SERVICES = 14,
      VT_ADVANCED_FEATURES = 16,
      VT_FBS_FILES = 18
    };

    const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Object>> *objects() const {
      return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Object>> *>(VT_OBJECTS);
    }

    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Object>> *mutable_objects() {
      return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<reflection::Object>> *>(VT_OBJECTS);
    }

    const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Enum>> *enums() const {
      return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Enum>> *>(VT_ENUMS);
    }

    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Enum>> *mutable_enums() {
      return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<reflection::Enum>> *>(VT_ENUMS);
    }

    const ::flatbuffers::String *file_ident() const {
      return GetPointer<const ::flatbuffers::String *>(VT_FILE_IDENT);
    }

    ::flatbuffers::String *mutable_file_ident() {
      return GetPointer<::flatbuffers::String *>(VT_FILE_IDENT);
    }

    const ::flatbuffers::String *file_ext() const {
      return GetPointer<const ::flatbuffers::String *>(VT_FILE_EXT);
    }

    ::flatbuffers::String *mutable_file_ext() {
      return GetPointer<::flatbuffers::String *>(VT_FILE_EXT);
    }

    const reflection::Object *root_table() const {
      return GetPointer<const reflection::Object *>(VT_ROOT_TABLE);
    }

    reflection::Object *mutable_root_table() {
      return GetPointer<reflection::Object *>(VT_ROOT_TABLE);
    }

    const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Service>> *services() const {
      return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Service>> *>(VT_SERVICES);
    }

    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::Service>> *mutable_services() {
      return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<reflection::Service>> *>(VT_SERVICES);
    }

    reflection::AdvancedFeatures advanced_features() const {
      return static_cast<reflection::AdvancedFeatures>(GetField<uint64_t>(VT_ADVANCED_FEATURES, 0));
    }

    bool mutate_advanced_features(
      reflection::AdvancedFeatures _advanced_features = static_cast<reflection::AdvancedFeatures>(0)) {
      return SetField<uint64_t>(VT_ADVANCED_FEATURES, static_cast<uint64_t>(_advanced_features), 0);
    }

    /// All the files used in this compilation. Files are relative to where
    /// flatc was invoked.
    const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::SchemaFile>> *fbs_files() const {
      return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<reflection::SchemaFile>> *>(VT_FBS_FILES);
    }

    ::flatbuffers::Vector<::flatbuffers::Offset<reflection::SchemaFile>> *mutable_fbs_files() {
      return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<reflection::SchemaFile>> *>(VT_FBS_FILES);
    }

    template <size_t Index>
    auto get_field() const {
      if constexpr (Index == 0)
        return objects();
      else if constexpr (Index == 1)
        return enums();
      else if constexpr (Index == 2)
        return file_ident();
      else if constexpr (Index == 3)
        return file_ext();
      else if constexpr (Index == 4)
        return root_table();
      else if constexpr (Index == 5)
        return services();
      else if constexpr (Index == 6)
        return advanced_features();
      else if constexpr (Index == 7)
        return fbs_files();
      else
        static_assert(Index != Index, "Invalid Field Index");
    }

    bool Verify(::flatbuffers::Verifier &verifier) const {
      return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_OBJECTS) &&
             verifier.VerifyVector(objects()) && verifier.VerifyVectorOfTables(objects()) &&
             VerifyOffsetRequired(verifier, VT_ENUMS) && verifier.VerifyVector(enums()) &&
             verifier.VerifyVectorOfTables(enums()) && VerifyOffset(verifier, VT_FILE_IDENT) &&
             verifier.VerifyString(file_ident()) && VerifyOffset(verifier, VT_FILE_EXT) &&
             verifier.VerifyString(file_ext()) && VerifyOffset(verifier, VT_ROOT_TABLE) &&
             verifier.VerifyTable(root_table()) && VerifyOffset(verifier, VT_SERVICES) &&
             verifier.VerifyVector(services()) && verifier.VerifyVectorOfTables(services()) &&
             VerifyField<uint64_t>(verifier, VT_ADVANCED_FEATURES, 8) && VerifyOffset(verifier, VT_FBS_FILES) &&
             verifier.VerifyVector(fbs_files()) && verifier.VerifyVectorOfTables(fbs_files()) && verifier.EndTable();
    }

    SchemaT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SchemaT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static ::flatbuffers::Offset<Schema> Pack(
      ::flatbuffers::FlatBufferBuilder &_fbb, const SchemaT *_o,
      const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
  };

  struct SchemaBuilder {
    typedef Schema Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;

    void add_objects(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::Object>>> objects) {
      fbb_.AddOffset(Schema::VT_OBJECTS, objects);
    }

    void add_enums(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::Enum>>> enums) {
      fbb_.AddOffset(Schema::VT_ENUMS, enums);
    }

    void add_file_ident(::flatbuffers::Offset<::flatbuffers::String> file_ident) {
      fbb_.AddOffset(Schema::VT_FILE_IDENT, file_ident);
    }

    void add_file_ext(::flatbuffers::Offset<::flatbuffers::String> file_ext) {
      fbb_.AddOffset(Schema::VT_FILE_EXT, file_ext);
    }

    void add_root_table(::flatbuffers::Offset<reflection::Object> root_table) {
      fbb_.AddOffset(Schema::VT_ROOT_TABLE, root_table);
    }

    void add_services(
      ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::Service>>> services) {
      fbb_.AddOffset(Schema::VT_SERVICES, services);
    }

    void add_advanced_features(reflection::AdvancedFeatures advanced_features) {
      fbb_.AddElement<uint64_t>(Schema::VT_ADVANCED_FEATURES, static_cast<uint64_t>(advanced_features), 0);
    }

    void add_fbs_files(
      ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::SchemaFile>>> fbs_files) {
      fbb_.AddOffset(Schema::VT_FBS_FILES, fbs_files);
    }

    explicit SchemaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
      start_ = fbb_.StartTable();
    }

    ::flatbuffers::Offset<Schema> Finish() {
      const auto end = fbb_.EndTable(start_);
      auto o = ::flatbuffers::Offset<Schema>(end);
      fbb_.Required(o, Schema::VT_OBJECTS);
      fbb_.Required(o, Schema::VT_ENUMS);
      return o;
    }
  };

  inline ::flatbuffers::Offset<Schema> CreateSchema(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::Object>>> objects = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::Enum>>> enums = 0,
    ::flatbuffers::Offset<::flatbuffers::String> file_ident = 0,
    ::flatbuffers::Offset<::flatbuffers::String> file_ext = 0, ::flatbuffers::Offset<reflection::Object> root_table = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::Service>>> services = 0,
    reflection::AdvancedFeatures advanced_features = static_cast<reflection::AdvancedFeatures>(0),
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<reflection::SchemaFile>>> fbs_files = 0) {
    SchemaBuilder builder_(_fbb);
    builder_.add_advanced_features(advanced_features);
    builder_.add_fbs_files(fbs_files);
    builder_.add_services(services);
    builder_.add_root_table(root_table);
    builder_.add_file_ext(file_ext);
    builder_.add_file_ident(file_ident);
    builder_.add_enums(enums);
    builder_.add_objects(objects);
    return builder_.Finish();
  }

  struct Schema::Traits {
    using type = Schema;
    static auto constexpr Create = CreateSchema;
    static constexpr auto name = "Schema";
    static constexpr auto fully_qualified_name = "reflection.Schema";
    static constexpr size_t fields_number = 8;
    static constexpr std::array<const char *, fields_number> field_names = {
      "objects", "enums", "file_ident", "file_ext", "root_table", "services", "advanced_features", "fbs_files"
    };
    template <size_t Index>
    using FieldType = decltype(std::declval<type>().get_field<Index>());
  };

  inline ::flatbuffers::Offset<Schema> CreateSchemaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, std::vector<::flatbuffers::Offset<reflection::Object>> *objects = nullptr,
    std::vector<::flatbuffers::Offset<reflection::Enum>> *enums = nullptr, const char *file_ident = nullptr,
    const char *file_ext = nullptr, ::flatbuffers::Offset<reflection::Object> root_table = 0,
    std::vector<::flatbuffers::Offset<reflection::Service>> *services = nullptr,
    reflection::AdvancedFeatures advanced_features = static_cast<reflection::AdvancedFeatures>(0),
    std::vector<::flatbuffers::Offset<reflection::SchemaFile>> *fbs_files = nullptr) {
    auto objects__ = objects ? _fbb.CreateVectorOfSortedTables<reflection::Object>(objects) : 0;
    auto enums__ = enums ? _fbb.CreateVectorOfSortedTables<reflection::Enum>(enums) : 0;
    auto file_ident__ = file_ident ? _fbb.CreateString(file_ident) : 0;
    auto file_ext__ = file_ext ? _fbb.CreateString(file_ext) : 0;
    auto services__ = services ? _fbb.CreateVectorOfSortedTables<reflection::Service>(services) : 0;
    auto fbs_files__ = fbs_files ? _fbb.CreateVectorOfSortedTables<reflection::SchemaFile>(fbs_files) : 0;
    return reflection::CreateSchema(
      _fbb, objects__, enums__, file_ident__, file_ext__, root_table, services__, advanced_features, fbs_files__);
  }

  ::flatbuffers::Offset<Schema> CreateSchema(
    ::flatbuffers::FlatBufferBuilder &_fbb, const SchemaT *_o,
    const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

  inline bool operator==(const TypeT &lhs, const TypeT &rhs) {
    return (lhs.base_type == rhs.base_type) && (lhs.element == rhs.element) && (lhs.index == rhs.index) &&
           (lhs.fixed_length == rhs.fixed_length) && (lhs.base_size == rhs.base_size) &&
           (lhs.element_size == rhs.element_size);
  }

  inline bool operator!=(const TypeT &lhs, const TypeT &rhs) {
    return !(lhs == rhs);
  }

  inline TypeT *Type::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
    auto _o = std::make_unique<TypeT>();
    UnPackTo(_o.get(), _resolver);
    return _o.release();
  }

  inline void Type::UnPackTo(TypeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
      auto _e = base_type();
      _o->base_type = _e;
    }
    {
      auto _e = element();
      _o->element = _e;
    }
    {
      auto _e = index();
      _o->index = _e;
    }
    {
      auto _e = fixed_length();
      _o->fixed_length = _e;
    }
    {
      auto _e = base_size();
      _o->base_size = _e;
    }
    {
      auto _e = element_size();
      _o->element_size = _e;
    }
  }

  inline ::flatbuffers::Offset<Type> Type::Pack(
    ::flatbuffers::FlatBufferBuilder &_fbb, const TypeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
    return CreateType(_fbb, _o, _rehasher);
  }

  inline ::flatbuffers::Offset<Type> CreateType(
    ::flatbuffers::FlatBufferBuilder &_fbb, const TypeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;

    struct _VectorArgs {
      ::flatbuffers::FlatBufferBuilder *__fbb;
      const TypeT *__o;
      const ::flatbuffers::rehasher_function_t *__rehasher;
    } _va = { &_fbb, _o, _rehasher };

    (void)_va;
    auto _base_type = _o->base_type;
    auto _element = _o->element;
    auto _index = _o->index;
    auto _fixed_length = _o->fixed_length;
    auto _base_size = _o->base_size;
    auto _element_size = _o->element_size;
    return reflection::CreateType(_fbb, _base_type, _element, _index, _fixed_length, _base_size, _element_size);
  }

  inline bool operator==(const KeyValueT &lhs, const KeyValueT &rhs) {
    return (lhs.key == rhs.key) && (lhs.value == rhs.value);
  }

  inline bool operator!=(const KeyValueT &lhs, const KeyValueT &rhs) {
    return !(lhs == rhs);
  }

  inline KeyValueT *KeyValue::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
    auto _o = std::make_unique<KeyValueT>();
    UnPackTo(_o.get(), _resolver);
    return _o.release();
  }

  inline void KeyValue::UnPackTo(KeyValueT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
      auto _e = key();
      if (_e)
        _o->key = _e->str();
    }
    {
      auto _e = value();
      if (_e)
        _o->value = _e->str();
    }
  }

  inline ::flatbuffers::Offset<KeyValue> KeyValue::Pack(
    ::flatbuffers::FlatBufferBuilder &_fbb, const KeyValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
    return CreateKeyValue(_fbb, _o, _rehasher);
  }

  inline ::flatbuffers::Offset<KeyValue> CreateKeyValue(
    ::flatbuffers::FlatBufferBuilder &_fbb, const KeyValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;

    struct _VectorArgs {
      ::flatbuffers::FlatBufferBuilder *__fbb;
      const KeyValueT *__o;
      const ::flatbuffers::rehasher_function_t *__rehasher;
    } _va = { &_fbb, _o, _rehasher };

    (void)_va;
    auto _key = _fbb.CreateString(_o->key);
    auto _value = _o->value.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->value);
    return reflection::CreateKeyValue(_fbb, _key, _value);
  }

  inline bool operator==(const EnumValT &lhs, const EnumValT &rhs) {
    return (lhs.name == rhs.name) && (lhs.value == rhs.value) &&
           ((lhs.union_type == rhs.union_type) ||
            (lhs.union_type && rhs.union_type && *lhs.union_type == *rhs.union_type)) &&
           (lhs.documentation == rhs.documentation) &&
           (lhs.attributes.size() == rhs.attributes.size() &&
            std::equal(
              lhs.attributes.cbegin(), lhs.attributes.cend(), rhs.attributes.cbegin(),
              [](std::unique_ptr<reflection::KeyValueT> const &a, std::unique_ptr<reflection::KeyValueT> const &b) {
                return (a == b) || (a && b && *a == *b);
              }));
  }

  inline bool operator!=(const EnumValT &lhs, const EnumValT &rhs) {
    return !(lhs == rhs);
  }

  inline EnumValT::EnumValT(const EnumValT &o)
      : name(o.name)
      , value(o.value)
      , union_type((o.union_type) ? new reflection::TypeT(*o.union_type) : nullptr)
      , documentation(o.documentation) {
    attributes.reserve(o.attributes.size());
    for (const auto &attributes_ : o.attributes) {
      attributes.emplace_back((attributes_) ? new reflection::KeyValueT(*attributes_) : nullptr);
    }
  }

  inline EnumValT &EnumValT::operator=(EnumValT o) FLATBUFFERS_NOEXCEPT {
    std::swap(name, o.name);
    std::swap(value, o.value);
    std::swap(union_type, o.union_type);
    std::swap(documentation, o.documentation);
    std::swap(attributes, o.attributes);
    return *this;
  }

  inline EnumValT *EnumVal::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
    auto _o = std::make_unique<EnumValT>();
    UnPackTo(_o.get(), _resolver);
    return _o.release();
  }

  inline void EnumVal::UnPackTo(EnumValT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
      auto _e = name();
      if (_e)
        _o->name = _e->str();
    }
    {
      auto _e = value();
      _o->value = _e;
    }
    {
      auto _e = union_type();
      if (_e) {
        if (_o->union_type) {
          _e->UnPackTo(_o->union_type.get(), _resolver);
        } else {
          _o->union_type = std::unique_ptr<reflection::TypeT>(_e->UnPack(_resolver));
        }
      } else if (_o->union_type) {
        _o->union_type.reset();
      }
    }
    {
      auto _e = documentation();
      if (_e) {
        _o->documentation.resize(_e->size());
        for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
          _o->documentation[_i] = _e->Get(_i)->str();
        }
      } else {
        _o->documentation.resize(0);
      }
    }
    {
      auto _e = attributes();
      if (_e) {
        _o->attributes.resize(_e->size());
        for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
          if (_o->attributes[_i]) {
            _e->Get(_i)->UnPackTo(_o->attributes[_i].get(), _resolver);
          } else {
            _o->attributes[_i] = std::unique_ptr<reflection::KeyValueT>(_e->Get(_i)->UnPack(_resolver));
          };
        }
      } else {
        _o->attributes.resize(0);
      }
    }
  }

  inline ::flatbuffers::Offset<EnumVal> EnumVal::Pack(
    ::flatbuffers::FlatBufferBuilder &_fbb, const EnumValT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
    return CreateEnumVal(_fbb, _o, _rehasher);
  }

  inline ::flatbuffers::Offset<EnumVal> CreateEnumVal(
    ::flatbuffers::FlatBufferBuilder &_fbb, const EnumValT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;

    struct _VectorArgs {
      ::flatbuffers::FlatBufferBuilder *__fbb;
      const EnumValT *__o;
      const ::flatbuffers::rehasher_function_t *__rehasher;
    } _va = { &_fbb, _o, _rehasher };

    (void)_va;
    auto _name = _fbb.CreateString(_o->name);
    auto _value = _o->value;
    auto _union_type = _o->union_type ? CreateType(_fbb, _o->union_type.get(), _rehasher) : 0;
    auto _documentation = _fbb.CreateVectorOfStrings(_o->documentation);
    auto _attributes = _fbb.CreateVector<::flatbuffers::Offset<reflection::KeyValue>>(
      _o->attributes.size(),
      [](size_t i, _VectorArgs *__va) {
        return CreateKeyValue(*__va->__fbb, __va->__o->attributes[i].get(), __va->__rehasher);
      },
      &_va);
    return reflection::CreateEnumVal(_fbb, _name, _value, _union_type, _documentation, _attributes);
  }

  inline bool operator==(const EnumT &lhs, const EnumT &rhs) {
    return (lhs.name == rhs.name) &&
           (lhs.values.size() == rhs.values.size() &&
            std::equal(
              lhs.values.cbegin(), lhs.values.cend(), rhs.values.cbegin(),
              [](std::unique_ptr<reflection::EnumValT> const &a, std::unique_ptr<reflection::EnumValT> const &b) {
                return (a == b) || (a && b && *a == *b);
              })) &&
           (lhs.is_union == rhs.is_union) &&
           ((lhs.underlying_type == rhs.underlying_type) ||
            (lhs.underlying_type && rhs.underlying_type && *lhs.underlying_type == *rhs.underlying_type)) &&
           (lhs.attributes.size() == rhs.attributes.size() &&
            std::equal(
              lhs.attributes.cbegin(), lhs.attributes.cend(), rhs.attributes.cbegin(),
              [](std::unique_ptr<reflection::KeyValueT> const &a, std::unique_ptr<reflection::KeyValueT> const &b) {
                return (a == b) || (a && b && *a == *b);
              })) &&
           (lhs.documentation == rhs.documentation) && (lhs.declaration_file == rhs.declaration_file);
  }

  inline bool operator!=(const EnumT &lhs, const EnumT &rhs) {
    return !(lhs == rhs);
  }

  inline EnumT::EnumT(const EnumT &o)
      : name(o.name)
      , is_union(o.is_union)
      , underlying_type((o.underlying_type) ? new reflection::TypeT(*o.underlying_type) : nullptr)
      , documentation(o.documentation)
      , declaration_file(o.declaration_file) {
    values.reserve(o.values.size());
    for (const auto &values_ : o.values) {
      values.emplace_back((values_) ? new reflection::EnumValT(*values_) : nullptr);
    }
    attributes.reserve(o.attributes.size());
    for (const auto &attributes_ : o.attributes) {
      attributes.emplace_back((attributes_) ? new reflection::KeyValueT(*attributes_) : nullptr);
    }
  }

  inline EnumT &EnumT::operator=(EnumT o) FLATBUFFERS_NOEXCEPT {
    std::swap(name, o.name);
    std::swap(values, o.values);
    std::swap(is_union, o.is_union);
    std::swap(underlying_type, o.underlying_type);
    std::swap(attributes, o.attributes);
    std::swap(documentation, o.documentation);
    std::swap(declaration_file, o.declaration_file);
    return *this;
  }

  inline EnumT *Enum::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
    auto _o = std::make_unique<EnumT>();
    UnPackTo(_o.get(), _resolver);
    return _o.release();
  }

  inline void Enum::UnPackTo(EnumT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
      auto _e = name();
      if (_e)
        _o->name = _e->str();
    }
    {
      auto _e = values();
      if (_e) {
        _o->values.resize(_e->size());
        for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
          if (_o->values[_i]) {
            _e->Get(_i)->UnPackTo(_o->values[_i].get(), _resolver);
          } else {
            _o->values[_i] = std::unique_ptr<reflection::EnumValT>(_e->Get(_i)->UnPack(_resolver));
          };
        }
      } else {
        _o->values.resize(0);
      }
    }
    {
      auto _e = is_union();
      _o->is_union = _e;
    }
    {
      auto _e = underlying_type();
      if (_e) {
        if (_o->underlying_type) {
          _e->UnPackTo(_o->underlying_type.get(), _resolver);
        } else {
          _o->underlying_type = std::unique_ptr<reflection::TypeT>(_e->UnPack(_resolver));
        }
      } else if (_o->underlying_type) {
        _o->underlying_type.reset();
      }
    }
    {
      auto _e = attributes();
      if (_e) {
        _o->attributes.resize(_e->size());
        for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
          if (_o->attributes[_i]) {
            _e->Get(_i)->UnPackTo(_o->attributes[_i].get(), _resolver);
          } else {
            _o->attributes[_i] = std::unique_ptr<reflection::KeyValueT>(_e->Get(_i)->UnPack(_resolver));
          };
        }
      } else {
        _o->attributes.resize(0);
      }
    }
    {
      auto _e = documentation();
      if (_e) {
        _o->documentation.resize(_e->size());
        for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
          _o->documentation[_i] = _e->Get(_i)->str();
        }
      } else {
        _o->documentation.resize(0);
      }
    }
    {
      auto _e = declaration_file();
      if (_e)
        _o->declaration_file = _e->str();
    }
  }

  inline ::flatbuffers::Offset<Enum> Enum::Pack(
    ::flatbuffers::FlatBufferBuilder &_fbb, const EnumT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
    return CreateEnum(_fbb, _o, _rehasher);
  }

  inline ::flatbuffers::Offset<Enum> CreateEnum(
    ::flatbuffers::FlatBufferBuilder &_fbb, const EnumT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;

    struct _VectorArgs {
      ::flatbuffers::FlatBufferBuilder *__fbb;
      const EnumT *__o;
      const ::flatbuffers::rehasher_function_t *__rehasher;
    } _va = { &_fbb, _o, _rehasher };

    (void)_va;
    auto _name = _fbb.CreateString(_o->name);
    auto _values = _fbb.CreateVector<::flatbuffers::Offset<reflection::EnumVal>>(
      _o->values.size(),
      [](size_t i, _VectorArgs *__va) {
        return CreateEnumVal(*__va->__fbb, __va->__o->values[i].get(), __va->__rehasher);
      },
      &_va);
    auto _is_union = _o->is_union;
    auto _underlying_type = _o->underlying_type ? CreateType(_fbb, _o->underlying_type.get(), _rehasher) : 0;
    auto _attributes = _fbb.CreateVector<::flatbuffers::Offset<reflection::KeyValue>>(
      _o->attributes.size(),
      [](size_t i, _VectorArgs *__va) {
        return CreateKeyValue(*__va->__fbb, __va->__o->attributes[i].get(), __va->__rehasher);
      },
      &_va);
    auto _documentation = _fbb.CreateVectorOfStrings(_o->documentation);
    auto _declaration_file =
      _o->declaration_file.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->declaration_file);
    return reflection::CreateEnum(
      _fbb, _name, _values, _is_union, _underlying_type, _attributes, _documentation, _declaration_file);
  }

  inline bool operator==(const FieldT &lhs, const FieldT &rhs) {
    return (lhs.name == rhs.name) && ((lhs.type == rhs.type) || (lhs.type && rhs.type && *lhs.type == *rhs.type)) &&
           (lhs.id == rhs.id) && (lhs.offset == rhs.offset) && (lhs.default_integer == rhs.default_integer) &&
           (lhs.default_real == rhs.default_real) && (lhs.deprecated == rhs.deprecated) &&
           (lhs.required == rhs.required) && (lhs.key == rhs.key) &&
           (lhs.attributes.size() == rhs.attributes.size() &&
            std::equal(
              lhs.attributes.cbegin(), lhs.attributes.cend(), rhs.attributes.cbegin(),
              [](std::unique_ptr<reflection::KeyValueT> const &a, std::unique_ptr<reflection::KeyValueT> const &b) {
                return (a == b) || (a && b && *a == *b);
              })) &&
           (lhs.documentation == rhs.documentation) && (lhs.optional == rhs.optional) && (lhs.padding == rhs.padding) &&
           (lhs.offset64 == rhs.offset64);
  }

  inline bool operator!=(const FieldT &lhs, const FieldT &rhs) {
    return !(lhs == rhs);
  }

  inline FieldT::FieldT(const FieldT &o)
      : name(o.name)
      , type((o.type) ? new reflection::TypeT(*o.type) : nullptr)
      , id(o.id)
      , offset(o.offset)
      , default_integer(o.default_integer)
      , default_real(o.default_real)
      , deprecated(o.deprecated)
      , required(o.required)
      , key(o.key)
      , documentation(o.documentation)
      , optional(o.optional)
      , padding(o.padding)
      , offset64(o.offset64) {
    attributes.reserve(o.attributes.size());
    for (const auto &attributes_ : o.attributes) {
      attributes.emplace_back((attributes_) ? new reflection::KeyValueT(*attributes_) : nullptr);
    }
  }

  inline FieldT &FieldT::operator=(FieldT o) FLATBUFFERS_NOEXCEPT {
    std::swap(name, o.name);
    std::swap(type, o.type);
    std::swap(id, o.id);
    std::swap(offset, o.offset);
    std::swap(default_integer, o.default_integer);
    std::swap(default_real, o.default_real);
    std::swap(deprecated, o.deprecated);
    std::swap(required, o.required);
    std::swap(key, o.key);
    std::swap(attributes, o.attributes);
    std::swap(documentation, o.documentation);
    std::swap(optional, o.optional);
    std::swap(padding, o.padding);
    std::swap(offset64, o.offset64);
    return *this;
  }

  inline FieldT *Field::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
    auto _o = std::make_unique<FieldT>();
    UnPackTo(_o.get(), _resolver);
    return _o.release();
  }

  inline void Field::UnPackTo(FieldT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
      auto _e = name();
      if (_e)
        _o->name = _e->str();
    }
    {
      auto _e = type();
      if (_e) {
        if (_o->type) {
          _e->UnPackTo(_o->type.get(), _resolver);
        } else {
          _o->type = std::unique_ptr<reflection::TypeT>(_e->UnPack(_resolver));
        }
      } else if (_o->type) {
        _o->type.reset();
      }
    }
    {
      auto _e = id();
      _o->id = _e;
    }
    {
      auto _e = offset();
      _o->offset = _e;
    }
    {
      auto _e = default_integer();
      _o->default_integer = _e;
    }
    {
      auto _e = default_real();
      _o->default_real = _e;
    }
    {
      auto _e = deprecated();
      _o->deprecated = _e;
    }
    {
      auto _e = required();
      _o->required = _e;
    }
    {
      auto _e = key();
      _o->key = _e;
    }
    {
      auto _e = attributes();
      if (_e) {
        _o->attributes.resize(_e->size());
        for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
          if (_o->attributes[_i]) {
            _e->Get(_i)->UnPackTo(_o->attributes[_i].get(), _resolver);
          } else {
            _o->attributes[_i] = std::unique_ptr<reflection::KeyValueT>(_e->Get(_i)->UnPack(_resolver));
          };
        }
      } else {
        _o->attributes.resize(0);
      }
    }
    {
      auto _e = documentation();
      if (_e) {
        _o->documentation.resize(_e->size());
        for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
          _o->documentation[_i] = _e->Get(_i)->str();
        }
      } else {
        _o->documentation.resize(0);
      }
    }
    {
      auto _e = optional();
      _o->optional = _e;
    }
    {
      auto _e = padding();
      _o->padding = _e;
    }
    {
      auto _e = offset64();
      _o->offset64 = _e;
    }
  }

  inline ::flatbuffers::Offset<Field> Field::Pack(
    ::flatbuffers::FlatBufferBuilder &_fbb, const FieldT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
    return CreateField(_fbb, _o, _rehasher);
  }

  inline ::flatbuffers::Offset<Field> CreateField(
    ::flatbuffers::FlatBufferBuilder &_fbb, const FieldT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;

    struct _VectorArgs {
      ::flatbuffers::FlatBufferBuilder *__fbb;
      const FieldT *__o;
      const ::flatbuffers::rehasher_function_t *__rehasher;
    } _va = { &_fbb, _o, _rehasher };

    (void)_va;
    auto _name = _fbb.CreateString(_o->name);
    auto _type = _o->type ? CreateType(_fbb, _o->type.get(), _rehasher) : 0;
    auto _id = _o->id;
    auto _offset = _o->offset;
    auto _default_integer = _o->default_integer;
    auto _default_real = _o->default_real;
    auto _deprecated = _o->deprecated;
    auto _required = _o->required;
    auto _key = _o->key;
    auto _attributes = _fbb.CreateVector<::flatbuffers::Offset<reflection::KeyValue>>(
      _o->attributes.size(),
      [](size_t i, _VectorArgs *__va) {
        return CreateKeyValue(*__va->__fbb, __va->__o->attributes[i].get(), __va->__rehasher);
      },
      &_va);
    auto _documentation = _fbb.CreateVectorOfStrings(_o->documentation);
    auto _optional = _o->optional;
    auto _padding = _o->padding;
    auto _offset64 = _o->offset64;
    return reflection::CreateField(
      _fbb, _name, _type, _id, _offset, _default_integer, _default_real, _deprecated, _required, _key, _attributes,
      _documentation, _optional, _padding, _offset64);
  }

  inline bool operator==(const ObjectT &lhs, const ObjectT &rhs) {
    return (lhs.name == rhs.name) &&
           (lhs.fields.size() == rhs.fields.size() &&
            std::equal(
              lhs.fields.cbegin(), lhs.fields.cend(), rhs.fields.cbegin(),
              [](std::unique_ptr<reflection::FieldT> const &a, std::unique_ptr<reflection::FieldT> const &b) {
                return (a == b) || (a && b && *a == *b);
              })) &&
           (lhs.is_struct == rhs.is_struct) && (lhs.minalign == rhs.minalign) && (lhs.bytesize == rhs.bytesize) &&
           (lhs.attributes.size() == rhs.attributes.size() &&
            std::equal(
              lhs.attributes.cbegin(), lhs.attributes.cend(), rhs.attributes.cbegin(),
              [](std::unique_ptr<reflection::KeyValueT> const &a, std::unique_ptr<reflection::KeyValueT> const &b) {
                return (a == b) || (a && b && *a == *b);
              })) &&
           (lhs.documentation == rhs.documentation) && (lhs.declaration_file == rhs.declaration_file);
  }

  inline bool operator!=(const ObjectT &lhs, const ObjectT &rhs) {
    return !(lhs == rhs);
  }

  inline ObjectT::ObjectT(const ObjectT &o)
      : name(o.name)
      , is_struct(o.is_struct)
      , minalign(o.minalign)
      , bytesize(o.bytesize)
      , documentation(o.documentation)
      , declaration_file(o.declaration_file) {
    fields.reserve(o.fields.size());
    for (const auto &fields_ : o.fields) {
      fields.emplace_back((fields_) ? new reflection::FieldT(*fields_) : nullptr);
    }
    attributes.reserve(o.attributes.size());
    for (const auto &attributes_ : o.attributes) {
      attributes.emplace_back((attributes_) ? new reflection::KeyValueT(*attributes_) : nullptr);
    }
  }

  inline ObjectT &ObjectT::operator=(ObjectT o) FLATBUFFERS_NOEXCEPT {
    std::swap(name, o.name);
    std::swap(fields, o.fields);
    std::swap(is_struct, o.is_struct);
    std::swap(minalign, o.minalign);
    std::swap(bytesize, o.bytesize);
    std::swap(attributes, o.attributes);
    std::swap(documentation, o.documentation);
    std::swap(declaration_file, o.declaration_file);
    return *this;
  }

  inline ObjectT *Object::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
    auto _o = std::make_unique<ObjectT>();
    UnPackTo(_o.get(), _resolver);
    return _o.release();
  }

  inline void Object::UnPackTo(ObjectT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
      auto _e = name();
      if (_e)
        _o->name = _e->str();
    }
    {
      auto _e = fields();
      if (_e) {
        _o->fields.resize(_e->size());
        for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
          if (_o->fields[_i]) {
            _e->Get(_i)->UnPackTo(_o->fields[_i].get(), _resolver);
          } else {
            _o->fields[_i] = std::unique_ptr<reflection::FieldT>(_e->Get(_i)->UnPack(_resolver));
          };
        }
      } else {
        _o->fields.resize(0);
      }
    }
    {
      auto _e = is_struct();
      _o->is_struct = _e;
    }
    {
      auto _e = minalign();
      _o->minalign = _e;
    }
    {
      auto _e = bytesize();
      _o->bytesize = _e;
    }
    {
      auto _e = attributes();
      if (_e) {
        _o->attributes.resize(_e->size());
        for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
          if (_o->attributes[_i]) {
            _e->Get(_i)->UnPackTo(_o->attributes[_i].get(), _resolver);
          } else {
            _o->attributes[_i] = std::unique_ptr<reflection::KeyValueT>(_e->Get(_i)->UnPack(_resolver));
          };
        }
      } else {
        _o->attributes.resize(0);
      }
    }
    {
      auto _e = documentation();
      if (_e) {
        _o->documentation.resize(_e->size());
        for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
          _o->documentation[_i] = _e->Get(_i)->str();
        }
      } else {
        _o->documentation.resize(0);
      }
    }
    {
      auto _e = declaration_file();
      if (_e)
        _o->declaration_file = _e->str();
    }
  }

  inline ::flatbuffers::Offset<Object> Object::Pack(
    ::flatbuffers::FlatBufferBuilder &_fbb, const ObjectT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
    return CreateObject(_fbb, _o, _rehasher);
  }

  inline ::flatbuffers::Offset<Object> CreateObject(
    ::flatbuffers::FlatBufferBuilder &_fbb, const ObjectT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;

    struct _VectorArgs {
      ::flatbuffers::FlatBufferBuilder *__fbb;
      const ObjectT *__o;
      const ::flatbuffers::rehasher_function_t *__rehasher;
    } _va = { &_fbb, _o, _rehasher };

    (void)_va;
    auto _name = _fbb.CreateString(_o->name);
    auto _fields = _fbb.CreateVector<::flatbuffers::Offset<reflection::Field>>(
      _o->fields.size(),
      [](size_t i, _VectorArgs *__va) {
        return CreateField(*__va->__fbb, __va->__o->fields[i].get(), __va->__rehasher);
      },
      &_va);
    auto _is_struct = _o->is_struct;
    auto _minalign = _o->minalign;
    auto _bytesize = _o->bytesize;
    auto _attributes = _fbb.CreateVector<::flatbuffers::Offset<reflection::KeyValue>>(
      _o->attributes.size(),
      [](size_t i, _VectorArgs *__va) {
        return CreateKeyValue(*__va->__fbb, __va->__o->attributes[i].get(), __va->__rehasher);
      },
      &_va);
    auto _documentation = _fbb.CreateVectorOfStrings(_o->documentation);
    auto _declaration_file =
      _o->declaration_file.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->declaration_file);
    return reflection::CreateObject(
      _fbb, _name, _fields, _is_struct, _minalign, _bytesize, _attributes, _documentation, _declaration_file);
  }

  inline bool operator==(const RPCCallT &lhs, const RPCCallT &rhs) {
    return (lhs.name == rhs.name) &&
           ((lhs.request == rhs.request) || (lhs.request && rhs.request && *lhs.request == *rhs.request)) &&
           ((lhs.response == rhs.response) || (lhs.response && rhs.response && *lhs.response == *rhs.response)) &&
           (lhs.attributes.size() == rhs.attributes.size() &&
            std::equal(
              lhs.attributes.cbegin(), lhs.attributes.cend(), rhs.attributes.cbegin(),
              [](std::unique_ptr<reflection::KeyValueT> const &a, std::unique_ptr<reflection::KeyValueT> const &b) {
                return (a == b) || (a && b && *a == *b);
              })) &&
           (lhs.documentation == rhs.documentation);
  }

  inline bool operator!=(const RPCCallT &lhs, const RPCCallT &rhs) {
    return !(lhs == rhs);
  }

  inline RPCCallT::RPCCallT(const RPCCallT &o)
      : name(o.name)
      , request((o.request) ? new reflection::ObjectT(*o.request) : nullptr)
      , response((o.response) ? new reflection::ObjectT(*o.response) : nullptr)
      , documentation(o.documentation) {
    attributes.reserve(o.attributes.size());
    for (const auto &attributes_ : o.attributes) {
      attributes.emplace_back((attributes_) ? new reflection::KeyValueT(*attributes_) : nullptr);
    }
  }

  inline RPCCallT &RPCCallT::operator=(RPCCallT o) FLATBUFFERS_NOEXCEPT {
    std::swap(name, o.name);
    std::swap(request, o.request);
    std::swap(response, o.response);
    std::swap(attributes, o.attributes);
    std::swap(documentation, o.documentation);
    return *this;
  }

  inline RPCCallT *RPCCall::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
    auto _o = std::make_unique<RPCCallT>();
    UnPackTo(_o.get(), _resolver);
    return _o.release();
  }

  inline void RPCCall::UnPackTo(RPCCallT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
      auto _e = name();
      if (_e)
        _o->name = _e->str();
    }
    {
      auto _e = request();
      if (_e) {
        if (_o->request) {
          _e->UnPackTo(_o->request.get(), _resolver);
        } else {
          _o->request = std::unique_ptr<reflection::ObjectT>(_e->UnPack(_resolver));
        }
      } else if (_o->request) {
        _o->request.reset();
      }
    }
    {
      auto _e = response();
      if (_e) {
        if (_o->response) {
          _e->UnPackTo(_o->response.get(), _resolver);
        } else {
          _o->response = std::unique_ptr<reflection::ObjectT>(_e->UnPack(_resolver));
        }
      } else if (_o->response) {
        _o->response.reset();
      }
    }
    {
      auto _e = attributes();
      if (_e) {
        _o->attributes.resize(_e->size());
        for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
          if (_o->attributes[_i]) {
            _e->Get(_i)->UnPackTo(_o->attributes[_i].get(), _resolver);
          } else {
            _o->attributes[_i] = std::unique_ptr<reflection::KeyValueT>(_e->Get(_i)->UnPack(_resolver));
          };
        }
      } else {
        _o->attributes.resize(0);
      }
    }
    {
      auto _e = documentation();
      if (_e) {
        _o->documentation.resize(_e->size());
        for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
          _o->documentation[_i] = _e->Get(_i)->str();
        }
      } else {
        _o->documentation.resize(0);
      }
    }
  }

  inline ::flatbuffers::Offset<RPCCall> RPCCall::Pack(
    ::flatbuffers::FlatBufferBuilder &_fbb, const RPCCallT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
    return CreateRPCCall(_fbb, _o, _rehasher);
  }

  inline ::flatbuffers::Offset<RPCCall> CreateRPCCall(
    ::flatbuffers::FlatBufferBuilder &_fbb, const RPCCallT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;

    struct _VectorArgs {
      ::flatbuffers::FlatBufferBuilder *__fbb;
      const RPCCallT *__o;
      const ::flatbuffers::rehasher_function_t *__rehasher;
    } _va = { &_fbb, _o, _rehasher };

    (void)_va;
    auto _name = _fbb.CreateString(_o->name);
    auto _request = _o->request ? CreateObject(_fbb, _o->request.get(), _rehasher) : 0;
    auto _response = _o->response ? CreateObject(_fbb, _o->response.get(), _rehasher) : 0;
    auto _attributes = _fbb.CreateVector<::flatbuffers::Offset<reflection::KeyValue>>(
      _o->attributes.size(),
      [](size_t i, _VectorArgs *__va) {
        return CreateKeyValue(*__va->__fbb, __va->__o->attributes[i].get(), __va->__rehasher);
      },
      &_va);
    auto _documentation = _fbb.CreateVectorOfStrings(_o->documentation);
    return reflection::CreateRPCCall(_fbb, _name, _request, _response, _attributes, _documentation);
  }

  inline bool operator==(const ServiceT &lhs, const ServiceT &rhs) {
    return (lhs.name == rhs.name) &&
           (lhs.calls.size() == rhs.calls.size() &&
            std::equal(
              lhs.calls.cbegin(), lhs.calls.cend(), rhs.calls.cbegin(),
              [](std::unique_ptr<reflection::RPCCallT> const &a, std::unique_ptr<reflection::RPCCallT> const &b) {
                return (a == b) || (a && b && *a == *b);
              })) &&
           (lhs.attributes.size() == rhs.attributes.size() &&
            std::equal(
              lhs.attributes.cbegin(), lhs.attributes.cend(), rhs.attributes.cbegin(),
              [](std::unique_ptr<reflection::KeyValueT> const &a, std::unique_ptr<reflection::KeyValueT> const &b) {
                return (a == b) || (a && b && *a == *b);
              })) &&
           (lhs.documentation == rhs.documentation) && (lhs.declaration_file == rhs.declaration_file);
  }

  inline bool operator!=(const ServiceT &lhs, const ServiceT &rhs) {
    return !(lhs == rhs);
  }

  inline ServiceT::ServiceT(const ServiceT &o)
      : name(o.name)
      , documentation(o.documentation)
      , declaration_file(o.declaration_file) {
    calls.reserve(o.calls.size());
    for (const auto &calls_ : o.calls) {
      calls.emplace_back((calls_) ? new reflection::RPCCallT(*calls_) : nullptr);
    }
    attributes.reserve(o.attributes.size());
    for (const auto &attributes_ : o.attributes) {
      attributes.emplace_back((attributes_) ? new reflection::KeyValueT(*attributes_) : nullptr);
    }
  }

  inline ServiceT &ServiceT::operator=(ServiceT o) FLATBUFFERS_NOEXCEPT {
    std::swap(name, o.name);
    std::swap(calls, o.calls);
    std::swap(attributes, o.attributes);
    std::swap(documentation, o.documentation);
    std::swap(declaration_file, o.declaration_file);
    return *this;
  }

  inline ServiceT *Service::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
    auto _o = std::make_unique<ServiceT>();
    UnPackTo(_o.get(), _resolver);
    return _o.release();
  }

  inline void Service::UnPackTo(ServiceT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
      auto _e = name();
      if (_e)
        _o->name = _e->str();
    }
    {
      auto _e = calls();
      if (_e) {
        _o->calls.resize(_e->size());
        for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
          if (_o->calls[_i]) {
            _e->Get(_i)->UnPackTo(_o->calls[_i].get(), _resolver);
          } else {
            _o->calls[_i] = std::unique_ptr<reflection::RPCCallT>(_e->Get(_i)->UnPack(_resolver));
          };
        }
      } else {
        _o->calls.resize(0);
      }
    }
    {
      auto _e = attributes();
      if (_e) {
        _o->attributes.resize(_e->size());
        for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
          if (_o->attributes[_i]) {
            _e->Get(_i)->UnPackTo(_o->attributes[_i].get(), _resolver);
          } else {
            _o->attributes[_i] = std::unique_ptr<reflection::KeyValueT>(_e->Get(_i)->UnPack(_resolver));
          };
        }
      } else {
        _o->attributes.resize(0);
      }
    }
    {
      auto _e = documentation();
      if (_e) {
        _o->documentation.resize(_e->size());
        for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
          _o->documentation[_i] = _e->Get(_i)->str();
        }
      } else {
        _o->documentation.resize(0);
      }
    }
    {
      auto _e = declaration_file();
      if (_e)
        _o->declaration_file = _e->str();
    }
  }

  inline ::flatbuffers::Offset<Service> Service::Pack(
    ::flatbuffers::FlatBufferBuilder &_fbb, const ServiceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
    return CreateService(_fbb, _o, _rehasher);
  }

  inline ::flatbuffers::Offset<Service> CreateService(
    ::flatbuffers::FlatBufferBuilder &_fbb, const ServiceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;

    struct _VectorArgs {
      ::flatbuffers::FlatBufferBuilder *__fbb;
      const ServiceT *__o;
      const ::flatbuffers::rehasher_function_t *__rehasher;
    } _va = { &_fbb, _o, _rehasher };

    (void)_va;
    auto _name = _fbb.CreateString(_o->name);
    auto _calls = _fbb.CreateVector<::flatbuffers::Offset<reflection::RPCCall>>(
      _o->calls.size(),
      [](size_t i, _VectorArgs *__va) {
        return CreateRPCCall(*__va->__fbb, __va->__o->calls[i].get(), __va->__rehasher);
      },
      &_va);
    auto _attributes = _fbb.CreateVector<::flatbuffers::Offset<reflection::KeyValue>>(
      _o->attributes.size(),
      [](size_t i, _VectorArgs *__va) {
        return CreateKeyValue(*__va->__fbb, __va->__o->attributes[i].get(), __va->__rehasher);
      },
      &_va);
    auto _documentation = _fbb.CreateVectorOfStrings(_o->documentation);
    auto _declaration_file =
      _o->declaration_file.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->declaration_file);
    return reflection::CreateService(_fbb, _name, _calls, _attributes, _documentation, _declaration_file);
  }

  inline bool operator==(const SchemaFileT &lhs, const SchemaFileT &rhs) {
    return (lhs.filename == rhs.filename) && (lhs.included_filenames == rhs.included_filenames);
  }

  inline bool operator!=(const SchemaFileT &lhs, const SchemaFileT &rhs) {
    return !(lhs == rhs);
  }

  inline SchemaFileT *SchemaFile::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
    auto _o = std::make_unique<SchemaFileT>();
    UnPackTo(_o.get(), _resolver);
    return _o.release();
  }

  inline void SchemaFile::UnPackTo(SchemaFileT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
      auto _e = filename();
      if (_e)
        _o->filename = _e->str();
    }
    {
      auto _e = included_filenames();
      if (_e) {
        _o->included_filenames.resize(_e->size());
        for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
          _o->included_filenames[_i] = _e->Get(_i)->str();
        }
      } else {
        _o->included_filenames.resize(0);
      }
    }
  }

  inline ::flatbuffers::Offset<SchemaFile> SchemaFile::Pack(
    ::flatbuffers::FlatBufferBuilder &_fbb, const SchemaFileT *_o,
    const ::flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSchemaFile(_fbb, _o, _rehasher);
  }

  inline ::flatbuffers::Offset<SchemaFile> CreateSchemaFile(
    ::flatbuffers::FlatBufferBuilder &_fbb, const SchemaFileT *_o,
    const ::flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;

    struct _VectorArgs {
      ::flatbuffers::FlatBufferBuilder *__fbb;
      const SchemaFileT *__o;
      const ::flatbuffers::rehasher_function_t *__rehasher;
    } _va = { &_fbb, _o, _rehasher };

    (void)_va;
    auto _filename = _fbb.CreateString(_o->filename);
    auto _included_filenames = _fbb.CreateVectorOfStrings(_o->included_filenames);
    return reflection::CreateSchemaFile(_fbb, _filename, _included_filenames);
  }

  inline bool operator==(const SchemaT &lhs, const SchemaT &rhs) {
    return (lhs.objects.size() == rhs.objects.size() &&
            std::equal(
              lhs.objects.cbegin(), lhs.objects.cend(), rhs.objects.cbegin(),
              [](std::unique_ptr<reflection::ObjectT> const &a, std::unique_ptr<reflection::ObjectT> const &b) {
                return (a == b) || (a && b && *a == *b);
              })) &&
           (lhs.enums.size() == rhs.enums.size() &&
            std::equal(
              lhs.enums.cbegin(), lhs.enums.cend(), rhs.enums.cbegin(),
              [](std::unique_ptr<reflection::EnumT> const &a, std::unique_ptr<reflection::EnumT> const &b) {
                return (a == b) || (a && b && *a == *b);
              })) &&
           (lhs.file_ident == rhs.file_ident) && (lhs.file_ext == rhs.file_ext) &&
           ((lhs.root_table == rhs.root_table) ||
            (lhs.root_table && rhs.root_table && *lhs.root_table == *rhs.root_table)) &&
           (lhs.services.size() == rhs.services.size() &&
            std::equal(
              lhs.services.cbegin(), lhs.services.cend(), rhs.services.cbegin(),
              [](std::unique_ptr<reflection::ServiceT> const &a, std::unique_ptr<reflection::ServiceT> const &b) {
                return (a == b) || (a && b && *a == *b);
              })) &&
           (lhs.advanced_features == rhs.advanced_features) &&
           (lhs.fbs_files.size() == rhs.fbs_files.size() &&
            std::equal(
              lhs.fbs_files.cbegin(), lhs.fbs_files.cend(), rhs.fbs_files.cbegin(),
              [](std::unique_ptr<reflection::SchemaFileT> const &a, std::unique_ptr<reflection::SchemaFileT> const &b) {
                return (a == b) || (a && b && *a == *b);
              }));
  }

  inline bool operator!=(const SchemaT &lhs, const SchemaT &rhs) {
    return !(lhs == rhs);
  }

  inline SchemaT::SchemaT(const SchemaT &o)
      : file_ident(o.file_ident)
      , file_ext(o.file_ext)
      , root_table((o.root_table) ? new reflection::ObjectT(*o.root_table) : nullptr)
      , advanced_features(o.advanced_features) {
    objects.reserve(o.objects.size());
    for (const auto &objects_ : o.objects) {
      objects.emplace_back((objects_) ? new reflection::ObjectT(*objects_) : nullptr);
    }
    enums.reserve(o.enums.size());
    for (const auto &enums_ : o.enums) {
      enums.emplace_back((enums_) ? new reflection::EnumT(*enums_) : nullptr);
    }
    services.reserve(o.services.size());
    for (const auto &services_ : o.services) {
      services.emplace_back((services_) ? new reflection::ServiceT(*services_) : nullptr);
    }
    fbs_files.reserve(o.fbs_files.size());
    for (const auto &fbs_files_ : o.fbs_files) {
      fbs_files.emplace_back((fbs_files_) ? new reflection::SchemaFileT(*fbs_files_) : nullptr);
    }
  }

  inline SchemaT &SchemaT::operator=(SchemaT o) FLATBUFFERS_NOEXCEPT {
    std::swap(objects, o.objects);
    std::swap(enums, o.enums);
    std::swap(file_ident, o.file_ident);
    std::swap(file_ext, o.file_ext);
    std::swap(root_table, o.root_table);
    std::swap(services, o.services);
    std::swap(advanced_features, o.advanced_features);
    std::swap(fbs_files, o.fbs_files);
    return *this;
  }

  inline SchemaT *Schema::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
    auto _o = std::make_unique<SchemaT>();
    UnPackTo(_o.get(), _resolver);
    return _o.release();
  }

  inline void Schema::UnPackTo(SchemaT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
      auto _e = objects();
      if (_e) {
        _o->objects.resize(_e->size());
        for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
          if (_o->objects[_i]) {
            _e->Get(_i)->UnPackTo(_o->objects[_i].get(), _resolver);
          } else {
            _o->objects[_i] = std::unique_ptr<reflection::ObjectT>(_e->Get(_i)->UnPack(_resolver));
          };
        }
      } else {
        _o->objects.resize(0);
      }
    }
    {
      auto _e = enums();
      if (_e) {
        _o->enums.resize(_e->size());
        for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
          if (_o->enums[_i]) {
            _e->Get(_i)->UnPackTo(_o->enums[_i].get(), _resolver);
          } else {
            _o->enums[_i] = std::unique_ptr<reflection::EnumT>(_e->Get(_i)->UnPack(_resolver));
          };
        }
      } else {
        _o->enums.resize(0);
      }
    }
    {
      auto _e = file_ident();
      if (_e)
        _o->file_ident = _e->str();
    }
    {
      auto _e = file_ext();
      if (_e)
        _o->file_ext = _e->str();
    }
    {
      auto _e = root_table();
      if (_e) {
        if (_o->root_table) {
          _e->UnPackTo(_o->root_table.get(), _resolver);
        } else {
          _o->root_table = std::unique_ptr<reflection::ObjectT>(_e->UnPack(_resolver));
        }
      } else if (_o->root_table) {
        _o->root_table.reset();
      }
    }
    {
      auto _e = services();
      if (_e) {
        _o->services.resize(_e->size());
        for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
          if (_o->services[_i]) {
            _e->Get(_i)->UnPackTo(_o->services[_i].get(), _resolver);
          } else {
            _o->services[_i] = std::unique_ptr<reflection::ServiceT>(_e->Get(_i)->UnPack(_resolver));
          };
        }
      } else {
        _o->services.resize(0);
      }
    }
    {
      auto _e = advanced_features();
      _o->advanced_features = _e;
    }
    {
      auto _e = fbs_files();
      if (_e) {
        _o->fbs_files.resize(_e->size());
        for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
          if (_o->fbs_files[_i]) {
            _e->Get(_i)->UnPackTo(_o->fbs_files[_i].get(), _resolver);
          } else {
            _o->fbs_files[_i] = std::unique_ptr<reflection::SchemaFileT>(_e->Get(_i)->UnPack(_resolver));
          };
        }
      } else {
        _o->fbs_files.resize(0);
      }
    }
  }

  inline ::flatbuffers::Offset<Schema> Schema::Pack(
    ::flatbuffers::FlatBufferBuilder &_fbb, const SchemaT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSchema(_fbb, _o, _rehasher);
  }

  inline ::flatbuffers::Offset<Schema> CreateSchema(
    ::flatbuffers::FlatBufferBuilder &_fbb, const SchemaT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;

    struct _VectorArgs {
      ::flatbuffers::FlatBufferBuilder *__fbb;
      const SchemaT *__o;
      const ::flatbuffers::rehasher_function_t *__rehasher;
    } _va = { &_fbb, _o, _rehasher };

    (void)_va;
    auto _objects = _fbb.CreateVector<::flatbuffers::Offset<reflection::Object>>(
      _o->objects.size(),
      [](size_t i, _VectorArgs *__va) {
        return CreateObject(*__va->__fbb, __va->__o->objects[i].get(), __va->__rehasher);
      },
      &_va);
    auto _enums = _fbb.CreateVector<::flatbuffers::Offset<reflection::Enum>>(
      _o->enums.size(),
      [](size_t i, _VectorArgs *__va) {
        return CreateEnum(*__va->__fbb, __va->__o->enums[i].get(), __va->__rehasher);
      },
      &_va);
    auto _file_ident = _o->file_ident.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->file_ident);
    auto _file_ext = _o->file_ext.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->file_ext);
    auto _root_table = _o->root_table ? CreateObject(_fbb, _o->root_table.get(), _rehasher) : 0;
    auto _services = _fbb.CreateVector<::flatbuffers::Offset<reflection::Service>>(
      _o->services.size(),
      [](size_t i, _VectorArgs *__va) {
        return CreateService(*__va->__fbb, __va->__o->services[i].get(), __va->__rehasher);
      },
      &_va);
    auto _advanced_features = _o->advanced_features;
    auto _fbs_files = _fbb.CreateVector<::flatbuffers::Offset<reflection::SchemaFile>>(
      _o->fbs_files.size(),
      [](size_t i, _VectorArgs *__va) {
        return CreateSchemaFile(*__va->__fbb, __va->__o->fbs_files[i].get(), __va->__rehasher);
      },
      &_va);
    return reflection::CreateSchema(
      _fbb, _objects, _enums, _file_ident, _file_ext, _root_table, _services, _advanced_features, _fbs_files);
  }

  inline const ::flatbuffers::TypeTable *BaseTypeTypeTable() {
    static const ::flatbuffers::TypeCode type_codes[] = {
      { ::flatbuffers::ET_CHAR, 0, 0 }, { ::flatbuffers::ET_CHAR, 0, 0 }, { ::flatbuffers::ET_CHAR, 0, 0 },
      { ::flatbuffers::ET_CHAR, 0, 0 }, { ::flatbuffers::ET_CHAR, 0, 0 }, { ::flatbuffers::ET_CHAR, 0, 0 },
      { ::flatbuffers::ET_CHAR, 0, 0 }, { ::flatbuffers::ET_CHAR, 0, 0 }, { ::flatbuffers::ET_CHAR, 0, 0 },
      { ::flatbuffers::ET_CHAR, 0, 0 }, { ::flatbuffers::ET_CHAR, 0, 0 }, { ::flatbuffers::ET_CHAR, 0, 0 },
      { ::flatbuffers::ET_CHAR, 0, 0 }, { ::flatbuffers::ET_CHAR, 0, 0 }, { ::flatbuffers::ET_CHAR, 0, 0 },
      { ::flatbuffers::ET_CHAR, 0, 0 }, { ::flatbuffers::ET_CHAR, 0, 0 }, { ::flatbuffers::ET_CHAR, 0, 0 },
      { ::flatbuffers::ET_CHAR, 0, 0 }, { ::flatbuffers::ET_CHAR, 0, 0 }
    };
    static const ::flatbuffers::TypeFunction type_refs[] = { reflection::BaseTypeTypeTable };
    static const char *const names[] = { "None",   "UType", "Bool",  "Byte",  "UByte",    "Short",      "UShort",
                                         "Int",    "UInt",  "Long",  "ULong", "Float",    "Double",     "String",
                                         "Vector", "Obj",   "Union", "Array", "Vector64", "MaxBaseType" };
    static const ::flatbuffers::TypeTable tt = {
      ::flatbuffers::ST_ENUM, 20, type_codes, type_refs, nullptr, nullptr, names
    };
    return &tt;
  }

  inline const ::flatbuffers::TypeTable *AdvancedFeaturesTypeTable() {
    static const ::flatbuffers::TypeCode type_codes[] = { { ::flatbuffers::ET_ULONG, 0, 0 },
                                                          { ::flatbuffers::ET_ULONG, 0, 0 },
                                                          { ::flatbuffers::ET_ULONG, 0, 0 },
                                                          { ::flatbuffers::ET_ULONG, 0, 0 } };
    static const ::flatbuffers::TypeFunction type_refs[] = { reflection::AdvancedFeaturesTypeTable };
    static const int64_t values[] = { 1ULL, 2ULL, 4ULL, 8ULL };
    static const char *const names[] = { "AdvancedArrayFeatures", "AdvancedUnionFeatures", "OptionalScalars",
                                         "DefaultVectorsAndStrings" };
    static const ::flatbuffers::TypeTable tt = {
      ::flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, values, names
    };
    return &tt;
  }

  inline const ::flatbuffers::TypeTable *TypeTypeTable() {
    static const ::flatbuffers::TypeCode type_codes[] = {
      { ::flatbuffers::ET_CHAR, 0, 0 },    { ::flatbuffers::ET_CHAR, 0, 0 },  { ::flatbuffers::ET_INT, 0, -1 },
      { ::flatbuffers::ET_USHORT, 0, -1 }, { ::flatbuffers::ET_UINT, 0, -1 }, { ::flatbuffers::ET_UINT, 0, -1 }
    };
    static const ::flatbuffers::TypeFunction type_refs[] = { reflection::BaseTypeTypeTable };
    static const char *const names[] = { "base_type", "element", "index", "fixed_length", "base_size", "element_size" };
    static const ::flatbuffers::TypeTable tt = {
      ::flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
    };
    return &tt;
  }

  inline const ::flatbuffers::TypeTable *KeyValueTypeTable() {
    static const ::flatbuffers::TypeCode type_codes[] = { { ::flatbuffers::ET_STRING, 0, -1 },
                                                          { ::flatbuffers::ET_STRING, 0, -1 } };
    static const char *const names[] = { "key", "value" };
    static const ::flatbuffers::TypeTable tt = {
      ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
    };
    return &tt;
  }

  inline const ::flatbuffers::TypeTable *EnumValTypeTable() {
    static const ::flatbuffers::TypeCode type_codes[] = {
      { ::flatbuffers::ET_STRING, 0, -1 },  { ::flatbuffers::ET_LONG, 0, -1 },   { ::flatbuffers::ET_SEQUENCE, 0, 0 },
      { ::flatbuffers::ET_SEQUENCE, 0, 1 }, { ::flatbuffers::ET_STRING, 1, -1 }, { ::flatbuffers::ET_SEQUENCE, 1, 2 }
    };
    static const ::flatbuffers::TypeFunction type_refs[] = { reflection::ObjectTypeTable, reflection::TypeTypeTable,
                                                             reflection::KeyValueTypeTable };
    static const char *const names[] = { "name", "value", "object", "union_type", "documentation", "attributes" };
    static const ::flatbuffers::TypeTable tt = {
      ::flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
    };
    return &tt;
  }

  inline const ::flatbuffers::TypeTable *EnumTypeTable() {
    static const ::flatbuffers::TypeCode type_codes[] = {
      { ::flatbuffers::ET_STRING, 0, -1 },  { ::flatbuffers::ET_SEQUENCE, 1, 0 }, { ::flatbuffers::ET_BOOL, 0, -1 },
      { ::flatbuffers::ET_SEQUENCE, 0, 1 }, { ::flatbuffers::ET_SEQUENCE, 1, 2 }, { ::flatbuffers::ET_STRING, 1, -1 },
      { ::flatbuffers::ET_STRING, 0, -1 }
    };
    static const ::flatbuffers::TypeFunction type_refs[] = { reflection::EnumValTypeTable, reflection::TypeTypeTable,
                                                             reflection::KeyValueTypeTable };
    static const char *const names[] = { "name",       "values",        "is_union",        "underlying_type",
                                         "attributes", "documentation", "declaration_file" };
    static const ::flatbuffers::TypeTable tt = {
      ::flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, nullptr, names
    };
    return &tt;
  }

  inline const ::flatbuffers::TypeTable *FieldTypeTable() {
    static const ::flatbuffers::TypeCode type_codes[] = {
      { ::flatbuffers::ET_STRING, 0, -1 },  { ::flatbuffers::ET_SEQUENCE, 0, 0 }, { ::flatbuffers::ET_USHORT, 0, -1 },
      { ::flatbuffers::ET_USHORT, 0, -1 },  { ::flatbuffers::ET_LONG, 0, -1 },    { ::flatbuffers::ET_DOUBLE, 0, -1 },
      { ::flatbuffers::ET_BOOL, 0, -1 },    { ::flatbuffers::ET_BOOL, 0, -1 },    { ::flatbuffers::ET_BOOL, 0, -1 },
      { ::flatbuffers::ET_SEQUENCE, 1, 1 }, { ::flatbuffers::ET_STRING, 1, -1 },  { ::flatbuffers::ET_BOOL, 0, -1 },
      { ::flatbuffers::ET_USHORT, 0, -1 },  { ::flatbuffers::ET_BOOL, 0, -1 }
    };
    static const ::flatbuffers::TypeFunction type_refs[] = { reflection::TypeTypeTable, reflection::KeyValueTypeTable };
    static const char *const names[] = { "name",          "type",       "id",       "offset",  "default_integer",
                                         "default_real",  "deprecated", "required", "key",     "attributes",
                                         "documentation", "optional",   "padding",  "offset64" };
    static const ::flatbuffers::TypeTable tt = {
      ::flatbuffers::ST_TABLE, 14, type_codes, type_refs, nullptr, nullptr, names
    };
    return &tt;
  }

  inline const ::flatbuffers::TypeTable *ObjectTypeTable() {
    static const ::flatbuffers::TypeCode type_codes[] = {
      { ::flatbuffers::ET_STRING, 0, -1 }, { ::flatbuffers::ET_SEQUENCE, 1, 0 }, { ::flatbuffers::ET_BOOL, 0, -1 },
      { ::flatbuffers::ET_INT, 0, -1 },    { ::flatbuffers::ET_INT, 0, -1 },     { ::flatbuffers::ET_SEQUENCE, 1, 1 },
      { ::flatbuffers::ET_STRING, 1, -1 }, { ::flatbuffers::ET_STRING, 0, -1 }
    };
    static const ::flatbuffers::TypeFunction type_refs[] = { reflection::FieldTypeTable,
                                                             reflection::KeyValueTypeTable };
    static const char *const names[] = { "name",     "fields",     "is_struct",     "minalign",
                                         "bytesize", "attributes", "documentation", "declaration_file" };
    static const ::flatbuffers::TypeTable tt = {
      ::flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, names
    };
    return &tt;
  }

  inline const ::flatbuffers::TypeTable *RPCCallTypeTable() {
    static const ::flatbuffers::TypeCode type_codes[] = { { ::flatbuffers::ET_STRING, 0, -1 },
                                                          { ::flatbuffers::ET_SEQUENCE, 0, 0 },
                                                          { ::flatbuffers::ET_SEQUENCE, 0, 0 },
                                                          { ::flatbuffers::ET_SEQUENCE, 1, 1 },
                                                          { ::flatbuffers::ET_STRING, 1, -1 } };
    static const ::flatbuffers::TypeFunction type_refs[] = { reflection::ObjectTypeTable,
                                                             reflection::KeyValueTypeTable };
    static const char *const names[] = { "name", "request", "response", "attributes", "documentation" };
    static const ::flatbuffers::TypeTable tt = {
      ::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
    };
    return &tt;
  }

  inline const ::flatbuffers::TypeTable *ServiceTypeTable() {
    static const ::flatbuffers::TypeCode type_codes[] = { { ::flatbuffers::ET_STRING, 0, -1 },
                                                          { ::flatbuffers::ET_SEQUENCE, 1, 0 },
                                                          { ::flatbuffers::ET_SEQUENCE, 1, 1 },
                                                          { ::flatbuffers::ET_STRING, 1, -1 },
                                                          { ::flatbuffers::ET_STRING, 0, -1 } };
    static const ::flatbuffers::TypeFunction type_refs[] = { reflection::RPCCallTypeTable,
                                                             reflection::KeyValueTypeTable };
    static const char *const names[] = { "name", "calls", "attributes", "documentation", "declaration_file" };
    static const ::flatbuffers::TypeTable tt = {
      ::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
    };
    return &tt;
  }

  inline const ::flatbuffers::TypeTable *SchemaFileTypeTable() {
    static const ::flatbuffers::TypeCode type_codes[] = { { ::flatbuffers::ET_STRING, 0, -1 },
                                                          { ::flatbuffers::ET_STRING, 1, -1 } };
    static const char *const names[] = { "filename", "included_filenames" };
    static const ::flatbuffers::TypeTable tt = {
      ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
    };
    return &tt;
  }

  inline const ::flatbuffers::TypeTable *SchemaTypeTable() {
    static const ::flatbuffers::TypeCode type_codes[] = {
      { ::flatbuffers::ET_SEQUENCE, 1, 0 }, { ::flatbuffers::ET_SEQUENCE, 1, 1 }, { ::flatbuffers::ET_STRING, 0, -1 },
      { ::flatbuffers::ET_STRING, 0, -1 },  { ::flatbuffers::ET_SEQUENCE, 0, 0 }, { ::flatbuffers::ET_SEQUENCE, 1, 2 },
      { ::flatbuffers::ET_ULONG, 0, 3 },    { ::flatbuffers::ET_SEQUENCE, 1, 4 }
    };
    static const ::flatbuffers::TypeFunction type_refs[] = { reflection::ObjectTypeTable, reflection::EnumTypeTable,
                                                             reflection::ServiceTypeTable,
                                                             reflection::AdvancedFeaturesTypeTable,
                                                             reflection::SchemaFileTypeTable };
    static const char *const names[] = { "objects",    "enums",    "file_ident",        "file_ext",
                                         "root_table", "services", "advanced_features", "fbs_files" };
    static const ::flatbuffers::TypeTable tt = {
      ::flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, names
    };
    return &tt;
  }

  inline const reflection::Schema *GetSchema(const void *buf) {
    return ::flatbuffers::GetRoot<reflection::Schema>(buf);
  }

  inline const reflection::Schema *GetSizePrefixedSchema(const void *buf) {
    return ::flatbuffers::GetSizePrefixedRoot<reflection::Schema>(buf);
  }

  inline Schema *GetMutableSchema(void *buf) {
    return ::flatbuffers::GetMutableRoot<Schema>(buf);
  }

  inline reflection::Schema *GetMutableSizePrefixedSchema(void *buf) {
    return ::flatbuffers::GetMutableSizePrefixedRoot<reflection::Schema>(buf);
  }

  inline const char *SchemaIdentifier() {
    return "BFBS";
  }

  inline bool SchemaBufferHasIdentifier(const void *buf) {
    return ::flatbuffers::BufferHasIdentifier(buf, SchemaIdentifier());
  }

  inline bool SizePrefixedSchemaBufferHasIdentifier(const void *buf) {
    return ::flatbuffers::BufferHasIdentifier(buf, SchemaIdentifier(), true);
  }

  inline bool VerifySchemaBuffer(::flatbuffers::Verifier &verifier) {
    return verifier.VerifyBuffer<reflection::Schema>(SchemaIdentifier());
  }

  inline bool VerifySizePrefixedSchemaBuffer(::flatbuffers::Verifier &verifier) {
    return verifier.VerifySizePrefixedBuffer<reflection::Schema>(SchemaIdentifier());
  }

  inline const char *SchemaExtension() {
    return "bfbs";
  }

  inline void FinishSchemaBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb, ::flatbuffers::Offset<reflection::Schema> root) {
    fbb.Finish(root, SchemaIdentifier());
  }

  inline void FinishSizePrefixedSchemaBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb, ::flatbuffers::Offset<reflection::Schema> root) {
    fbb.FinishSizePrefixed(root, SchemaIdentifier());
  }

  inline std::unique_ptr<reflection::SchemaT> UnPackSchema(
    const void *buf, const ::flatbuffers::resolver_function_t *res = nullptr) {
    return std::unique_ptr<reflection::SchemaT>(GetSchema(buf)->UnPack(res));
  }

  inline std::unique_ptr<reflection::SchemaT> UnPackSizePrefixedSchema(
    const void *buf, const ::flatbuffers::resolver_function_t *res = nullptr) {
    return std::unique_ptr<reflection::SchemaT>(GetSizePrefixedSchema(buf)->UnPack(res));
  }

} // namespace reflection

#endif // FLATBUFFERS_GENERATED_REFLECTION_REFLECTION_H_
